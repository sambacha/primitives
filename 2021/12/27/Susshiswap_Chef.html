<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover"
  /><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Susshiswap_chef | Primitives</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Susshiswap_chef" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Analysis of sushiswap protocol - ÊñáÁ´†Êï¥Âêà" />
<meta property="og:description" content="Analysis of sushiswap protocol - ÊñáÁ´†Êï¥Âêà" />
<meta property="og:site_name" content="Primitives" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-12-27T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Susshiswap_chef" />
<script type="application/ld+json">
{"headline":"Susshiswap_chef","dateModified":"2021-12-27T00:00:00+00:00","datePublished":"2021-12-27T00:00:00+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"/primitives/2021/12/27/Susshiswap_Chef.html"},"url":"/primitives/2021/12/27/Susshiswap_Chef.html","description":"Analysis of sushiswap protocol - ÊñáÁ´†Êï¥Âêà","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link type="application/atom+xml" rel="alternate" href="/primitives/feed.xml" title="Primitives" /><!-- Emoji Favicon  -->
  <!-- Favicon -->
  <link
    rel="icon"
    href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üéÑ</text></svg>"
  />
  <!-- <link rel="shortcut icon" href="/primitives/favicon.ico"> -->

  <!-- Bootstrap CSS -->
  <link
    rel="stylesheet"
    href="https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css"
    integrity="sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu"
    crossorigin="anonymous"
  />

  <!-- Font Awesome -->
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"
    integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog=="
    crossorigin="anonymous"
  />

  <!-- Custom CSS -->
  <link rel="stylesheet" href="/primitives/assets/css/main.min.css" />
</head>
<body><!-- Navigation -->
<nav
  class="navbar navbar-default navbar-custom navbar-fixed-top invert"
>
  <div class="container-fluid">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header page-scroll">
      <a class="navbar-brand" href="/primitives/">Primitives</a>
      <button class="navbar-toggle" type="button">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div id="huxblog_navbar">
      <div class="navbar-collapse">
        <ul class="nav navbar-nav navbar-right">
          <li>
            <a href="/primitives/">Home</a>
          </li><li>
            <a href="/primitives/about/">About</a>
          </li><li>
            <a href="/primitives/archive/">Archive</a>
          </li><li class="search-icon">
            <a href="javascript:void(0)">
              <i class="fas fa-search"></i>
            </a>
          </li>
        </ul>
      </div>
    </div>
  </div>
</nav>
<!-- Search -->
<div class="search-page">
  <div class="search-icon-close-container">
    <span class="search-icon-close">
      <i class="fas fa-chevron-down"></i>
    </span>
  </div>

  <div class="search-main container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <form>
          <input type="text" id="search-input" placeholder="$ grep..." />
        </form>
        <div id="search-results" class="mini-post-list"></div>
      </div>
    </div>
  </div>
</div>
<!-- Post Header --><header
  class="intro-header style-text"
>
  <div class="header-mask"></div><div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-heading">
          <div class="tags"><a
              class="tag"
              href="/primitives/archive/?tag=analysis"
              title="analysis"
              >analysis</a
            ><a
              class="tag"
              href="/primitives/archive/?tag=sushiswap"
              title="sushiswap"
              >sushiswap</a
            ><a
              class="tag"
              href="/primitives/archive/?tag=protocol"
              title="protocol"
              >protocol</a
            ></div>
          <h1>Susshiswap_chef</h1>
          <h2 class="subheading"></h2>
          <span class="meta"
            >Posted by sambacha on December 27, 2021</span
          >
        </div>
      </div>
    </div>
  </div>
</header><!-- Post Content -->
<style>
  /* Place left on bigger screen */
  @media all and (min-width: 800px) {
    .anchorjs-link {
      position: absolute;
      left: -0.75em;
      font-size: 1.1em;
      margin-top: 0.1em;
    }
  }
</style>
<article>
  <div class="container">
    <div class="row">
      <!-- Post Container -->
      <div
        class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 post-container"
      ><h1 id="analysis-of-sushiswap-protocol---ÊñáÁ´†Êï¥Âêà">Analysis of sushiswap protocol - ÊñáÁ´†Êï¥Âêà</h1>

<blockquote>
  <h2 id="excerpt">Excerpt</h2>
  <p>Protocol Brief  SushiSwap It‚Äôs a bifurcation from Uniswap Decentrali</p>
</blockquote>

<hr />
<h4 id="protocol-brief"><strong>Protocol Brief</strong></h4>

<p>SushiSwap is a bifurcation from UniswapV2, which itself can trace back to Bancor Protocol.
 It continues in the trading model Uniswap The core design of ‚Äî‚ÄîAMM( Auto market makers ) Model , But with Uniswap The difference is SushiSwap Added economic reward model ,SushiSwap The transaction fee is 0.3%, among 0.25% Direct distribution to liquidity providers ,0.05% Buy into SUSHI And assigned to Sushi Token holders (Uniswap It is through the switch mode to decide whether to 0.05% The service charge to the developer team ),Sushi Reserved for each distribution 10% Provide future development iteration and safety audit for the project .</p>

<blockquote>
  <p>Sushiswap GitHub
https://github.com/sushiswap/sushiswap</p>
</blockquote>

<h4 id="vcs-structure"><strong>vcs structure</strong></h4>

<p>SushiSwap The source code structure of the protocol is as follows , In the later source code analysis stage, we mainly focus on time-locked contracts and SushiSwap Analyze the content of the document ,UniswapV2 The agreement is no longer in-depth , For more information, please refer to the previous UniswapV2 Protocol analysis article Ôºö</p>

<h4 id="source-code-analysis"><strong>Source code analysis</strong></h4>

<p>Next, we will SushiSwap Analysis of key documents;</p>

<ul>
  <li>SushiTokenÔºö Token contract , With voting function</li>
  <li>MasterChefÔºö take LPsTokens Deposit in SUSHI fram</li>
  <li>SushiMakerÔºö Collect transaction fees , Convert to SUSHI And send it to SushiBar</li>
  <li>SushiBarÔºö mortgage SUSHI To get more SUSHI</li>
  <li>MigratorÔºö hold MasterChef LP from Uniswap Migrate to SushiSwap</li>
  <li>GovernorAlpha+TimelockÔºö come from Compound The governance function of</li>
  <li>UniswapV2ÔºöUniswapV2 contract , Minor modifications were made to migrate the contract</li>
</ul>

<h5 id="timelock"><strong>Timelock</strong></h5>

<p>Timelock The contract will affect any updates executed by the smart contract 48 Hour time lock , Exit in function timelock after , It can be used 5 In multiple team signatures 3 One to execute , The picture below is SushiSwap In contract timelock The recorded information of Ôºö</p>

<p>https://app.sushi.com/governance</p>

<p>The following code is SushiSwap Official timelock Source code</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
</pre></td><td class="rouge-code"><pre>
<span class="c1">// SPDX-License-Identifier: MIT
</span>
<span class="c1">// COPIED FROM https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/GovernorAlpha.sol
// Copyright 2020 Compound Labs, Inc.
// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
// 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Ctrl+f for XXX to see all the modifications.
</span>
<span class="c1">// XXX: pragma solidity ^0.5.16;
</span><span class="k">pragma</span> <span class="n">solidity</span> <span class="mf">0.6</span><span class="p">.</span><span class="mi">12</span><span class="p">;</span>

<span class="c1">// XXX: import "./SafeMath.sol";
</span><span class="k">import</span> <span class="s">"@openzeppelin/contracts/math/SafeMath.sol"</span><span class="p">;</span>

<span class="k">contract</span> <span class="n">Timelock</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">SafeMath</span> <span class="k">for</span> <span class="kt">uint</span><span class="p">;</span>

    <span class="k">event</span> <span class="n">NewAdmin</span><span class="p">(</span><span class="kt">address</span> <span class="k">indexed</span> <span class="n">newAdmin</span><span class="p">);</span>
    <span class="k">event</span> <span class="n">NewPendingAdmin</span><span class="p">(</span><span class="kt">address</span> <span class="k">indexed</span> <span class="n">newPendingAdmin</span><span class="p">);</span>
    <span class="k">event</span> <span class="n">NewDelay</span><span class="p">(</span><span class="kt">uint</span> <span class="k">indexed</span> <span class="n">newDelay</span><span class="p">);</span>
    <span class="k">event</span> <span class="n">CancelTransaction</span><span class="p">(</span><span class="kt">bytes32</span> <span class="k">indexed</span> <span class="n">txHash</span><span class="p">,</span> <span class="kt">address</span> <span class="k">indexed</span> <span class="n">target</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">value</span><span class="p">,</span> <span class="kt">string</span> <span class="n">signature</span><span class="p">,</span>  <span class="kt">bytes</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">eta</span><span class="p">);</span>
    <span class="k">event</span> <span class="n">ExecuteTransaction</span><span class="p">(</span><span class="kt">bytes32</span> <span class="k">indexed</span> <span class="n">txHash</span><span class="p">,</span> <span class="kt">address</span> <span class="k">indexed</span> <span class="n">target</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">value</span><span class="p">,</span> <span class="kt">string</span> <span class="n">signature</span><span class="p">,</span>  <span class="kt">bytes</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">eta</span><span class="p">);</span>
    <span class="k">event</span> <span class="n">QueueTransaction</span><span class="p">(</span><span class="kt">bytes32</span> <span class="k">indexed</span> <span class="n">txHash</span><span class="p">,</span> <span class="kt">address</span> <span class="k">indexed</span> <span class="n">target</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">value</span><span class="p">,</span> <span class="kt">string</span> <span class="n">signature</span><span class="p">,</span> <span class="kt">bytes</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">eta</span><span class="p">);</span>

    <span class="kt">uint</span> <span class="k">public</span> <span class="k">constant</span> <span class="n">GRACE</span><span class="err">\</span><span class="n">_PERIOD</span> <span class="o">=</span> <span class="mi">14</span> <span class="kc">days</span><span class="p">;</span>
    <span class="kt">uint</span> <span class="k">public</span> <span class="k">constant</span> <span class="n">MINIMUM</span><span class="err">\</span><span class="n">_DELAY</span> <span class="o">=</span> <span class="mi">2</span> <span class="kc">days</span><span class="p">;</span>
    <span class="kt">uint</span> <span class="k">public</span> <span class="k">constant</span> <span class="n">MAXIMUM</span><span class="err">\</span><span class="n">_DELAY</span> <span class="o">=</span> <span class="mi">30</span> <span class="kc">days</span><span class="p">;</span>

    <span class="kt">address</span> <span class="k">public</span> <span class="n">admin</span><span class="p">;</span>
    <span class="kt">address</span> <span class="k">public</span> <span class="n">pendingAdmin</span><span class="p">;</span>
    <span class="kt">uint</span> <span class="k">public</span> <span class="n">delay</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="k">public</span> <span class="n">admin</span><span class="err">\</span><span class="n">_initialized</span><span class="p">;</span>

    <span class="k">mapping</span> <span class="p">(</span><span class="kt">bytes32</span> <span class="o">=&gt;</span> <span class="kt">bool</span><span class="p">)</span> <span class="k">public</span> <span class="n">queuedTransactions</span><span class="p">;</span>


    <span class="k">constructor</span><span class="p">(</span><span class="kt">address</span> <span class="n">admin</span><span class="err">\</span><span class="n">_</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">delay</span><span class="err">\</span><span class="n">_</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="nb">require</span><span class="p">(</span><span class="n">delay</span><span class="err">\</span><span class="n">_</span> <span class="o">&gt;=</span> <span class="n">MINIMUM</span><span class="err">\</span><span class="n">_DELAY</span><span class="p">,</span> <span class="s">"Timelock::constructor: Delay must exceed minimum delay."</span><span class="p">);</span>
        <span class="nb">require</span><span class="p">(</span><span class="n">delay</span><span class="err">\</span><span class="n">_</span> <span class="o">&lt;=</span> <span class="n">MAXIMUM</span><span class="err">\</span><span class="n">_DELAY</span><span class="p">,</span> <span class="s">"Timelock::constructor: Delay must not exceed maximum delay."</span><span class="p">);</span>

        <span class="n">admin</span> <span class="o">=</span> <span class="n">admin</span><span class="err">\</span><span class="n">_</span><span class="p">;</span>
        <span class="n">delay</span> <span class="o">=</span> <span class="n">delay</span><span class="err">\</span><span class="n">_</span><span class="p">;</span>
        <span class="n">admin</span><span class="err">\</span><span class="n">_initialized</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// XXX: function() external payable { }
</span>    <span class="k">receive</span><span class="p">()</span> <span class="k">external</span> <span class="k">payable</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">function</span> <span class="n">setDelay</span><span class="p">(</span><span class="kt">uint</span> <span class="n">delay</span><span class="err">\</span><span class="n">_</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="nb">require</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">sender</span> <span class="o">==</span> <span class="kt">address</span><span class="p">(</span><span class="nb">this</span><span class="p">),</span> <span class="s">"Timelock::setDelay: Call must come from Timelock."</span><span class="p">);</span>
        <span class="nb">require</span><span class="p">(</span><span class="n">delay</span><span class="err">\</span><span class="n">_</span> <span class="o">&gt;=</span> <span class="n">MINIMUM</span><span class="err">\</span><span class="n">_DELAY</span><span class="p">,</span> <span class="s">"Timelock::setDelay: Delay must exceed minimum delay."</span><span class="p">);</span>
        <span class="nb">require</span><span class="p">(</span><span class="n">delay</span><span class="err">\</span><span class="n">_</span> <span class="o">&lt;=</span> <span class="n">MAXIMUM</span><span class="err">\</span><span class="n">_DELAY</span><span class="p">,</span> <span class="s">"Timelock::setDelay: Delay must not exceed maximum delay."</span><span class="p">);</span>
        <span class="n">delay</span> <span class="o">=</span> <span class="n">delay</span><span class="err">\</span><span class="n">_</span><span class="p">;</span>

        <span class="k">emit</span> <span class="n">NewDelay</span><span class="p">(</span><span class="n">delay</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">function</span> <span class="n">acceptAdmin</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="nb">require</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">sender</span> <span class="o">==</span> <span class="n">pendingAdmin</span><span class="p">,</span> <span class="s">"Timelock::acceptAdmin: Call must come from pendingAdmin."</span><span class="p">);</span>
        <span class="n">admin</span> <span class="o">=</span> <span class="n">msg</span><span class="p">.</span><span class="n">sender</span><span class="p">;</span>
        <span class="n">pendingAdmin</span> <span class="o">=</span> <span class="kt">address</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

        <span class="k">emit</span> <span class="n">NewAdmin</span><span class="p">(</span><span class="n">admin</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">function</span> <span class="n">setPendingAdmin</span><span class="p">(</span><span class="kt">address</span> <span class="n">pendingAdmin</span><span class="err">\</span><span class="n">_</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="c1">// allows one time setting of admin for deployment purposes
</span>        <span class="k">if</span> <span class="p">(</span><span class="n">admin</span><span class="err">\</span><span class="n">_initialized</span><span class="p">)</span> <span class="p">{</span>
            <span class="nb">require</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">sender</span> <span class="o">==</span> <span class="kt">address</span><span class="p">(</span><span class="nb">this</span><span class="p">),</span> <span class="s">"Timelock::setPendingAdmin: Call must come from Timelock."</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nb">require</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">sender</span> <span class="o">==</span> <span class="n">admin</span><span class="p">,</span> <span class="s">"Timelock::setPendingAdmin: First call must come from admin."</span><span class="p">);</span>
            <span class="n">admin</span><span class="err">\</span><span class="n">_initialized</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">pendingAdmin</span> <span class="o">=</span> <span class="n">pendingAdmin</span><span class="err">\</span><span class="n">_</span><span class="p">;</span>

        <span class="k">emit</span> <span class="n">NewPendingAdmin</span><span class="p">(</span><span class="n">pendingAdmin</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">function</span> <span class="n">queueTransaction</span><span class="p">(</span><span class="kt">address</span> <span class="n">target</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">value</span><span class="p">,</span> <span class="kt">string</span> <span class="k">memory</span> <span class="n">signature</span><span class="p">,</span> <span class="kt">bytes</span> <span class="k">memory</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">eta</span><span class="p">)</span> <span class="k">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bytes32</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">require</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">sender</span> <span class="o">==</span> <span class="n">admin</span><span class="p">,</span> <span class="s">"Timelock::queueTransaction: Call must come from admin."</span><span class="p">);</span>
        <span class="nb">require</span><span class="p">(</span><span class="n">eta</span> <span class="o">&gt;=</span> <span class="n">getBlockTimestamp</span><span class="p">().</span><span class="n">add</span><span class="p">(</span><span class="n">delay</span><span class="p">),</span> <span class="s">"Timelock::queueTransaction: Estimated execution block must satisfy delay."</span><span class="p">);</span>

        <span class="kt">bytes32</span> <span class="n">txHash</span> <span class="o">=</span> <span class="nb">keccak256</span><span class="p">(</span><span class="n">abi</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">signature</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">eta</span><span class="p">));</span>
        <span class="n">queuedTransactions</span><span class="err">\</span><span class="p">[</span><span class="n">txHash</span><span class="err">\</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

        <span class="k">emit</span> <span class="n">QueueTransaction</span><span class="p">(</span><span class="n">txHash</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">signature</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">eta</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">txHash</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">function</span> <span class="n">cancelTransaction</span><span class="p">(</span><span class="kt">address</span> <span class="n">target</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">value</span><span class="p">,</span> <span class="kt">string</span> <span class="k">memory</span> <span class="n">signature</span><span class="p">,</span> <span class="kt">bytes</span> <span class="k">memory</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">eta</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="nb">require</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">sender</span> <span class="o">==</span> <span class="n">admin</span><span class="p">,</span> <span class="s">"Timelock::cancelTransaction: Call must come from admin."</span><span class="p">);</span>

        <span class="kt">bytes32</span> <span class="n">txHash</span> <span class="o">=</span> <span class="nb">keccak256</span><span class="p">(</span><span class="n">abi</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">signature</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">eta</span><span class="p">));</span>
        <span class="n">queuedTransactions</span><span class="err">\</span><span class="p">[</span><span class="n">txHash</span><span class="err">\</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

        <span class="k">emit</span> <span class="n">CancelTransaction</span><span class="p">(</span><span class="n">txHash</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">signature</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">eta</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">function</span> <span class="n">executeTransaction</span><span class="p">(</span><span class="kt">address</span> <span class="n">target</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">value</span><span class="p">,</span> <span class="kt">string</span> <span class="k">memory</span> <span class="n">signature</span><span class="p">,</span> <span class="kt">bytes</span> <span class="k">memory</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">eta</span><span class="p">)</span> <span class="k">public</span> <span class="k">payable</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bytes</span> <span class="k">memory</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">require</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">sender</span> <span class="o">==</span> <span class="n">admin</span><span class="p">,</span> <span class="s">"Timelock::executeTransaction: Call must come from admin."</span><span class="p">);</span>

        <span class="kt">bytes32</span> <span class="n">txHash</span> <span class="o">=</span> <span class="nb">keccak256</span><span class="p">(</span><span class="n">abi</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">signature</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">eta</span><span class="p">));</span>
        <span class="nb">require</span><span class="p">(</span><span class="n">queuedTransactions</span><span class="err">\</span><span class="p">[</span><span class="n">txHash</span><span class="err">\</span><span class="p">],</span> <span class="s">"Timelock::executeTransaction: Transaction hasn't been queued."</span><span class="p">);</span>
        <span class="nb">require</span><span class="p">(</span><span class="n">getBlockTimestamp</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">eta</span><span class="p">,</span> <span class="s">"Timelock::executeTransaction: Transaction hasn't surpassed time lock."</span><span class="p">);</span>
        <span class="nb">require</span><span class="p">(</span><span class="n">getBlockTimestamp</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">eta</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">GRACE</span><span class="err">\</span><span class="n">_PERIOD</span><span class="p">),</span> <span class="s">"Timelock::executeTransaction: Transaction is stale."</span><span class="p">);</span>

        <span class="n">queuedTransactions</span><span class="err">\</span><span class="p">[</span><span class="n">txHash</span><span class="err">\</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

        <span class="kt">bytes</span> <span class="k">memory</span> <span class="n">callData</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="kt">bytes</span><span class="p">(</span><span class="n">signature</span><span class="p">).</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">callData</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">callData</span> <span class="o">=</span> <span class="n">abi</span><span class="p">.</span><span class="n">encodePacked</span><span class="p">(</span><span class="kt">bytes4</span><span class="p">(</span><span class="nb">keccak256</span><span class="p">(</span><span class="kt">bytes</span><span class="p">(</span><span class="n">signature</span><span class="p">))),</span> <span class="n">data</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// solium-disable-next-line security/no-call-value
</span>        <span class="p">(</span><span class="kt">bool</span> <span class="n">success</span><span class="p">,</span> <span class="kt">bytes</span> <span class="k">memory</span> <span class="n">returnData</span><span class="p">)</span> <span class="o">=</span> <span class="n">target</span><span class="p">.</span><span class="nb">call</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="n">value</span><span class="p">)(</span><span class="n">callData</span><span class="p">);</span>
        <span class="nb">require</span><span class="p">(</span><span class="n">success</span><span class="p">,</span> <span class="s">"Timelock::executeTransaction: Transaction execution reverted."</span><span class="p">);</span>

        <span class="k">emit</span> <span class="n">ExecuteTransaction</span><span class="p">(</span><span class="n">txHash</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">signature</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">eta</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">returnData</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">function</span> <span class="n">getBlockTimestamp</span><span class="p">()</span> <span class="k">internal</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// solium-disable-next-line security/no-block-members
</span>        <span class="k">return</span> <span class="n">block</span><span class="p">.</span><span class="n">timestamp</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>At the beginning of the contract, a series of events are defined Ôºö</p>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="c1">// to update Admin
</span><span class="k">event</span> <span class="n">NewAdmin</span><span class="p">(</span><span class="kt">address</span> <span class="k">indexed</span> <span class="n">newAdmin</span><span class="p">);</span>
<span class="c1">// newly added Admin To Admin Preparation queue 
</span><span class="k">event</span> <span class="n">NewPendingAdmin</span><span class="p">(</span><span class="kt">address</span> <span class="k">indexed</span> <span class="n">newPendingAdmin</span><span class="p">);</span>
<span class="c1">// New delay time 
</span><span class="k">event</span> <span class="n">NewDelay</span><span class="p">(</span><span class="kt">uint</span> <span class="k">indexed</span> <span class="n">newDelay</span><span class="p">);</span>
<span class="c1">// Cancel the deal 
</span><span class="k">event</span> <span class="n">CancelTransaction</span><span class="p">(</span><span class="kt">bytes32</span> <span class="k">indexed</span> <span class="n">txHash</span><span class="p">,</span> <span class="kt">address</span> <span class="k">indexed</span> <span class="n">target</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">value</span><span class="p">,</span> <span class="kt">string</span> <span class="n">signature</span><span class="p">,</span>  <span class="kt">bytes</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">eta</span><span class="p">);</span>
<span class="c1">// Execute the transaction 
</span><span class="k">event</span> <span class="n">ExecuteTransaction</span><span class="p">(</span><span class="kt">bytes32</span> <span class="k">indexed</span> <span class="n">txHash</span><span class="p">,</span> <span class="kt">address</span> <span class="k">indexed</span> <span class="n">target</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">value</span><span class="p">,</span> <span class="kt">string</span> <span class="n">signature</span><span class="p">,</span>  <span class="kt">bytes</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">eta</span><span class="p">);</span>
<span class="c1">// Add transaction pair transaction queue 
</span><span class="k">event</span> <span class="n">QueueTransaction</span><span class="p">(</span><span class="kt">bytes32</span> <span class="k">indexed</span> <span class="n">txHash</span><span class="p">,</span> <span class="kt">address</span> <span class="k">indexed</span> <span class="n">target</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">value</span><span class="p">,</span> <span class="kt">string</span> <span class="n">signature</span><span class="p">,</span> <span class="kt">bytes</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">eta</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="language-solidity highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="rouge-code"><pre><span class="n">Then</span> <span class="n">the</span> <span class="n">minimum</span> <span class="n">delay</span> <span class="n">time</span><span class="p">,</span> <span class="n">maximum</span> <span class="n">delay</span> <span class="n">time</span> <span class="n">and</span> <span class="n">grace</span> <span class="n">period</span> <span class="n">are</span> <span class="n">defined</span> <span class="err">Ôºö</span>

<span class="kt">uint</span> <span class="k">public</span> <span class="k">constant</span> <span class="n">GRACE</span><span class="err">\</span><span class="n">_PERIOD</span> <span class="o">=</span> <span class="mi">14</span> <span class="kc">days</span><span class="p">;</span>    <span class="c1">// Grace period :14 God 
</span><span class="kt">uint</span> <span class="k">public</span> <span class="k">constant</span> <span class="n">MINIMUM</span><span class="err">\</span><span class="n">_DELAY</span> <span class="o">=</span> <span class="mi">2</span> <span class="kc">days</span><span class="p">;</span>    <span class="c1">// Minimum delay time 
</span><span class="kt">uint</span> <span class="k">public</span> <span class="k">constant</span> <span class="n">MAXIMUM</span><span class="err">\</span><span class="n">_DELAY</span> <span class="o">=</span> <span class="mi">30</span> <span class="kc">days</span><span class="p">;</span>   <span class="c1">// Maximum delay time 
</span>
<span class="n">Then</span> <span class="n">declare</span> <span class="n">the</span> <span class="n">global</span> <span class="n">variables</span> <span class="n">that</span> <span class="n">will</span> <span class="n">be</span> <span class="n">used</span> <span class="n">later</span> <span class="err">Ôºö</span>

<span class="kt">address</span> <span class="k">public</span> <span class="n">admin</span><span class="p">;</span>             <span class="c1">//admin Address 
</span><span class="kt">address</span> <span class="k">public</span> <span class="n">pendingAdmin</span><span class="p">;</span>    <span class="c1">//pendingAdmin Address 
</span><span class="kt">uint</span> <span class="k">public</span> <span class="n">delay</span><span class="p">;</span>          <span class="c1">// Delay time 
</span><span class="kt">bool</span> <span class="k">public</span> <span class="n">admin</span><span class="err">\</span><span class="n">_initialized</span><span class="p">;</span>    <span class="c1">//admin Is the address initialized 
</span><span class="k">mapping</span> <span class="p">(</span><span class="kt">bytes32</span> <span class="o">=&gt;</span> <span class="kt">bool</span><span class="p">)</span> <span class="k">public</span> <span class="n">queuedTransactions</span><span class="p">;</span> <span class="c1">// Use mapping Store transaction queue , The key value pair is bytes32=&gt;bool( Transaction bytes and whether in queue Boolean )
</span>
<span class="n">Then</span> <span class="n">initialize</span> <span class="kr">in</span> <span class="n">the</span> <span class="k">constructor</span> <span class="p">,</span> <span class="n">requirement</span> <span class="n">delay</span> <span class="n">The</span> <span class="n">delay</span> <span class="k">is</span> <span class="n">between</span> <span class="n">the</span> <span class="n">minimum</span> <span class="n">delay</span> <span class="n">and</span> <span class="n">the</span> <span class="n">maximum</span> <span class="n">delay</span> <span class="p">,</span> <span class="n">After</span> <span class="n">initialization</span> <span class="n">admin</span> <span class="n">Address</span> <span class="p">,</span> <span class="n">And</span> <span class="n">will</span> <span class="n">admin</span><span class="err">\</span><span class="n">_initialized</span> <span class="n">Set</span> <span class="n">to</span> <span class="nb">false</span><span class="o">:</span>

    <span class="k">constructor</span><span class="p">(</span><span class="kt">address</span> <span class="n">admin</span><span class="err">\</span><span class="n">_</span><span class="p">,</span> <span class="kt">uint</span> <span class="n">delay</span><span class="err">\</span><span class="n">_</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="nb">require</span><span class="p">(</span><span class="n">delay</span><span class="err">\</span><span class="n">_</span> <span class="o">&gt;=</span> <span class="n">MINIMUM</span><span class="err">\</span><span class="n">_DELAY</span><span class="p">,</span> <span class="s">"Timelock::constructor: Delay must exceed minimum delay."</span><span class="p">);</span>
        <span class="nb">require</span><span class="p">(</span><span class="n">delay</span><span class="err">\</span><span class="n">_</span> <span class="o">&lt;=</span> <span class="n">MAXIMUM</span><span class="err">\</span><span class="n">_DELAY</span><span class="p">,</span> <span class="s">"Timelock::constructor: Delay must not exceed maximum delay."</span><span class="p">);</span>

        <span class="n">admin</span> <span class="o">=</span> <span class="n">admin</span><span class="err">\</span><span class="n">_</span><span class="p">;</span>
        <span class="n">delay</span> <span class="o">=</span> <span class="n">delay</span><span class="err">\</span><span class="n">_</span><span class="p">;</span>
        <span class="n">admin</span><span class="err">\</span><span class="n">_initialized</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>After that receive The function is used to accept the transfer of tokens from the external account address and contract address to the current contract address Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>// XXX: function() external payable { }
receive() external payable { }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>setDelay Function to update the delay , The function requires the caller of the function to be the current contract address itself , At the same time, the delay is required to be between the shortest delay and the maximum delay , After through emit Triggering event Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>function setDelay(uint delay\_) public {
    require(msg.sender == address(this), "Timelock::setDelay: Call must come from Timelock.");
    require(delay\_ &gt;= MINIMUM\_DELAY, "Timelock::setDelay: Delay must exceed minimum delay.");
    require(delay\_ &lt;= MAXIMUM\_DELAY, "Timelock::setDelay: Delay must not exceed maximum delay.");
    delay = delay\_;

    emit NewDelay(delay);
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>acceptAdmin Function to update admin Address , This function requires the function caller to be admin Address in queue , Then ask to update the current admin And will admin The address in was removed , After through emit Triggering event Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre>function acceptAdmin() public {
    require(msg.sender == pendingAdmin, "Timelock::acceptAdmin: Call must come from pendingAdmin.");
    admin = msg.sender;
    pendingAdmin = address(0);

    emit NewAdmin(admin);
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>setPendingAdmin The function sets the in the queue admin Address , First of all, I will check admin_initialized Is it true( In the constructor admin Address initialized , however admin_initialized Still for false, Nothing new ), If false entering else, Then check whether the current function caller is admin Address , If so, update admin_initialized, Set it to true, Then update pendingAdmin, When called the second time setPendingAdmin when , At this time admin_initialized Already been true, Therefore, the caller will be required to be the current contract address , That‚Äôs why SushiSwap Officially ‚Äú Administrative rights have been given to time lock (timelock) contract ‚Äú Why Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre>function setPendingAdmin(address pendingAdmin\_) public {
    // allows one time setting of admin for deployment purposes
    if (admin\_initialized) {
        require(msg.sender == address(this), "Timelock::setPendingAdmin: Call must come from Timelock.");
    } else {
        require(msg.sender == admin, "Timelock::setPendingAdmin: First call must come from admin.");
        admin\_initialized = true;
    }
    pendingAdmin = pendingAdmin\_;

    emit NewPendingAdmin(pendingAdmin);
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>queueTransaction Used to add a transaction to the transaction queue , The function first retrieves whether the function caller is admin Address , Then retrieve whether the delay requirements are met , Then calculate the transaction hash, Then add the transaction to the transaction queue , And pass emit Triggering event Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) {
    require(msg.sender == admin, "Timelock::queueTransaction: Call must come from admin.");
    require(eta &gt;= getBlockTimestamp().add(delay), "Timelock::queueTransaction: Estimated execution block must satisfy delay.");

    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));
    queuedTransactions\[txHash\] = true;

    emit QueueTransaction(txHash, target, value, signature, data, eta);
    return txHash;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>cancelTransaction The function cancels a transaction in the transaction queue , First, it will retrieve whether the caller of the current function is a contract admin Address , Then calculate a transaction hash, Then remove the transaction from the transaction queue , After through emit Triggering event Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public {
    require(msg.sender == admin, "Timelock::cancelTransaction: Call must come from admin.");

    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));
    queuedTransactions\[txHash\] = false;

    emit CancelTransaction(txHash, target, value, signature, data, eta);
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>executeTransaction Function to execute a transaction , This function first retrieves whether the caller of the current function is admin Address , Then calculate a transaction hash, Then retrieve whether the delay condition is met , Then remove the transaction from the transaction queue , And then through call Call execute transaction , Finally through emit Triggering event Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="rouge-code"><pre>function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bytes memory) {
    require(msg.sender == admin, "Timelock::executeTransaction: Call must come from admin.");

    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));
    require(queuedTransactions\[txHash\], "Timelock::executeTransaction: Transaction hasn't been queued.");
    require(getBlockTimestamp() &gt;= eta, "Timelock::executeTransaction: Transaction hasn't surpassed time lock.");
    require(getBlockTimestamp() &lt;= eta.add(GRACE\_PERIOD), "Timelock::executeTransaction: Transaction is stale.");

    queuedTransactions\[txHash\] = false;

    bytes memory callData;

    if (bytes(signature).length == 0) {
        callData = data;
    } else {
        callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);
    }

    // solium-disable-next-line security/no-call-value
    (bool success, bytes memory returnData) = target.call.value(value)(callData);
    require(success, "Timelock::executeTransaction: Transaction execution reverted.");

    emit ExecuteTransaction(txHash, target, value, signature, data, eta);

    return returnData;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>getBlockTimestamp The function is simple , Just get the timestamp of the current block Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>function getBlockTimestamp() internal view returns (uint) {
    // solium-disable-next-line security/no-block-members
    return block.timestamp;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<h5 id="sushitoken"><strong>SushiToken</strong></h5>

<p>SushiToken It‚Äôs a token contract , With voting function , The following is the official source code Ôºö</p>

<p>// SPDX-License-Identifier: MIT</p>

<p>pragma solidity 0.6.12;</p>

<p>import ‚Äú@openzeppelin/contracts/token/ERC20/ERC20.sol‚Äù;
import ‚Äú@openzeppelin/contracts/access/Ownable.sol‚Äù;</p>

<p>// SushiToken with Governance.
contract SushiToken is ERC20(‚ÄúSushiToken‚Äù, ‚ÄúSUSHI‚Äù), Ownable {
    /// @notice Creates `_amount` token to `_to`. Must only be called by the owner (MasterChef).
    function mint(address _to, uint256 _amount) public onlyOwner {
        _mint(_to, _amount);
        _moveDelegates(address(0), _delegates[_to], _amount);
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre></td><td class="rouge-code"><pre>// Copied and modified from YAM code:
// https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernanceStorage.sol
// https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernance.sol
// Which is copied and modified from COMPOUND:
// https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/Comp.sol

/// @notice A record of each accounts delegate
mapping (address =&gt; address) internal \_delegates;

/// @notice A checkpoint for marking number of votes from a given block
struct Checkpoint {
    uint32 fromBlock;
    uint256 votes;
}

/// @notice A record of votes checkpoints for each account, by index
mapping (address =&gt; mapping (uint32 =&gt; Checkpoint)) public checkpoints;

/// @notice The number of checkpoints for each account
mapping (address =&gt; uint32) public numCheckpoints;

/// @notice The EIP-712 typehash for the contract's domain
bytes32 public constant DOMAIN\_TYPEHASH = keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)");

/// @notice The EIP-712 typehash for the delegation struct used by the contract
bytes32 public constant DELEGATION\_TYPEHASH = keccak256("Delegation(address delegatee,uint256 nonce,uint256 expiry)");

/// @notice A record of states for signing / validating signatures
mapping (address =&gt; uint) public nonces;

  /// @notice An event thats emitted when an account changes its delegate
event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);

/// @notice An event thats emitted when a delegate account's vote balance changes
event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);

/\*\*
 \* @notice Delegate votes from \`msg.sender\` to \`delegatee\`
 \* @param delegator The address to get delegatee for
 \*/
function delegates(address delegator)
    external
    view
    returns (address) {
    return \_delegates\[delegator\];
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**
    * @notice Delegate votes from `msg.sender` to `delegatee`
    * @param delegatee The address to delegate votes to
    */
    function delegate(address delegatee) external {
        return _delegate(msg.sender, delegatee);
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
</pre></td><td class="rouge-code"><pre>/\*\*
 \* @notice Delegates votes from signatory to \`delegatee\`
 \* @param delegatee The address to delegate votes to
 \* @param nonce The contract state required to match the signature
 \* @param expiry The time at which to expire the signature
 \* @param v The recovery byte of the signature
 \* @param r Half of the ECDSA signature pair
 \* @param s Half of the ECDSA signature pair
 \*/
function delegateBySig(
    address delegatee,
    uint nonce,
    uint expiry,
    uint8 v,
    bytes32 r,
    bytes32 s
)
    external {
    bytes32 domainSeparator = keccak256(
        abi.encode(
            DOMAIN\_TYPEHASH,
            keccak256(bytes(name())),
            getChainId(),
            address(this)
        )
    );

    bytes32 structHash = keccak256(
        abi.encode(
            DELEGATION\_TYPEHASH,
            delegatee,
            nonce,
            expiry
        )
    );

    bytes32 digest = keccak256(
        abi.encodePacked(
            "\\x19\\x01",
            domainSeparator,
            structHash
        )
    );

    address signatory = ecrecover(digest, v, r, s);
    require(signatory != address(0), "SUSHI::delegateBySig: invalid signature");
    require(nonce == nonces\[signatory\]++, "SUSHI::delegateBySig: invalid nonce");
    require(now &lt;= expiry, "SUSHI::delegateBySig: signature expired");
    return \_delegate(signatory, delegatee);
}

/\*\*
 \* @notice Gets the current votes balance for \`account\`
 \* @param account The address to get votes balance
 \* @return The number of current votes for \`account\`
 \*/
function getCurrentVotes(address account)
    external
    view
    returns (uint256) {
    uint32 nCheckpoints = numCheckpoints\[account\];
    return nCheckpoints &gt; 0 ? checkpoints\[account\]\[nCheckpoints - 1\].votes : 0;
}

/\*\*
 \* @notice Determine the prior number of votes for an account as of a block number
 \* @dev Block number must be a finalized block or else this function will revert to prevent misinformation.
 \* @param account The address of the account to check
 \* @param blockNumber The block number to get the vote balance at
 \* @return The number of votes the account had as of the given block
 \*/
function getPriorVotes(address account, uint blockNumber)
    external
    view
    returns (uint256) {
    require(blockNumber &lt; block.number, "SUSHI::getPriorVotes: not yet determined");

    uint32 nCheckpoints = numCheckpoints\[account\];
    if (nCheckpoints == 0) {
        return 0;
    }

    // First check most recent balance
    if (checkpoints\[account\]\[nCheckpoints - 1\].fromBlock &lt;= blockNumber) {
        return checkpoints\[account\]\[nCheckpoints - 1\].votes;
    }

    // Next check implicit zero balance
    if (checkpoints\[account\]\[0\].fromBlock &gt; blockNumber) {
        return 0;
    }

    uint32 lower = 0;
    uint32 upper = nCheckpoints - 1;
    while (upper &gt; lower) {
        uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow
        Checkpoint memory cp = checkpoints\[account\]\[center\];
        if (cp.fromBlock == blockNumber) {
            return cp.votes;
        } else if (cp.fromBlock &lt; blockNumber) {
            lower = center;
        } else {
            upper = center - 1;
        }
    }
    return checkpoints\[account\]\[lower\].votes;
}

function \_delegate(address delegator, address delegatee)
    internal {
    address currentDelegate = \_delegates\[delegator\];
    uint256 delegatorBalance = balanceOf(delegator); // balance of underlying SUSHIs (not scaled);
    \_delegates\[delegator\] = delegatee;

    emit DelegateChanged(delegator, currentDelegate, delegatee);

    \_moveDelegates(currentDelegate, delegatee, delegatorBalance);
}

function \_moveDelegates(address srcRep, address dstRep, uint256 amount) internal {
    if (srcRep != dstRep &amp;&amp; amount &gt; 0) {
        if (srcRep != address(0)) {
            // decrease old representative
            uint32 srcRepNum = numCheckpoints\[srcRep\];
            uint256 srcRepOld = srcRepNum &gt; 0 ? checkpoints\[srcRep\]\[srcRepNum - 1\].votes : 0;
            uint256 srcRepNew = srcRepOld.sub(amount);
            \_writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);
        }

        if (dstRep != address(0)) {
            // increase new representative
            uint32 dstRepNum = numCheckpoints\[dstRep\];
            uint256 dstRepOld = dstRepNum &gt; 0 ? checkpoints\[dstRep\]\[dstRepNum - 1\].votes : 0;
            uint256 dstRepNew = dstRepOld.add(amount);
            \_writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);
        }
    }
}

function \_writeCheckpoint(
    address delegatee,
    uint32 nCheckpoints,
    uint256 oldVotes,
    uint256 newVotes
)
    internal {
    uint32 blockNumber = safe32(block.number, "SUSHI::\_writeCheckpoint: block number exceeds 32 bits");

    if (nCheckpoints &gt; 0 &amp;&amp; checkpoints\[delegatee\]\[nCheckpoints - 1\].fromBlock == blockNumber) {
        checkpoints\[delegatee\]\[nCheckpoints - 1\].votes = newVotes;
    } else {
        checkpoints\[delegatee\]\[nCheckpoints\] = Checkpoint(blockNumber, newVotes);
        numCheckpoints\[delegatee\] = nCheckpoints + 1;
    }

    emit DelegateVotesChanged(delegatee, oldVotes, newVotes);
}

function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {
    require(n &lt; 2\*\*32, errorMessage);
    return uint32(n);
}

function getChainId() internal pure returns (uint) {
    uint256 chainId;
    assembly { chainId := chainid() }
    return chainId;
} }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This function inherits from ERC20( This is a novel way of writing , Use it directly ERC-20 Initializes the current contract with the constructor of ) and Ownable:</p>

<p>contract SushiToken is ERC20(‚ÄúSushiToken‚Äù, ‚ÄúSUSHI‚Äù), Ownable {</p>

<p>After that mint The function is used to issue additional tokens , This function needs to pass two parameters Ôºö</p>

<ul>
  <li>toÔºö Address to accept new tokens</li>
  <li>_amountÔºö Number of new tokens</li>
</ul>

<p>The function consists of onlyOwner Modifier modification , Contract required owner call , Then call UniswapV2 Of mint Function to perform coinage operations Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>function mint(address \_to, uint256 \_amount) public onlyOwner {
    \_mint(\_to, \_amount);
    \_moveDelegates(address(0), \_delegates\[\_to\], \_amount);
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Ownable.sol
    // M1 - M5: OK
    // C1 - C21: OK
    modifier onlyOwner() {
        require(msg.sender == owner, ‚ÄúOwnable: caller is not the owner‚Äù);
        _;
    }</p>

<p>// UniswapV2ERC20.sol
    function _mint(address to, uint value) internal {
        totalSupply = totalSupply.add(value);
        balanceOf[to] = balanceOf[to].add(value);
        emit Transfer(address(0), to, value);
    }</p>

<p>Then call _moveDelegates Transfer entrustment , Here, we take the parameters passed in before as an example for analysis, and go directly to the last if In the sentence , Then according to dstRep To retrieve the inspection site of the account ( A check site that marks the number of votes for a particular block ), When the number of inspection sites of the account is greater than 0, Retrieve the number of votes from the last checkpoint and assign it to srcRepOld, If there are no detection points, it is set to 0, Then use the original number of votes plus the number of assets to be transferred , As new votes ( It can also be said that additional issuance token Related to the number of votes ,1 token representative 1 ticket ), Then call _writeCheckpoint Update check site Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>/// @notice A checkpoint for marking number of votes from a given block
struct Checkpoint {
    uint32 fromBlock;
    uint256 votes;
}
/// @notice A record of votes checkpoints for each account, by index
mapping (address =&gt; mapping (uint32 =&gt; Checkpoint)) public checkpoints;

/// @notice The number of checkpoints for each account
mapping (address =&gt; uint32) public numCheckpoints;
</pre></td></tr></tbody></table></code></pre></div></div>

<p>function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal {
        if (srcRep != dstRep &amp;&amp; amount &gt; 0) {
            if (srcRep != address(0)) {
                // decrease old representative
                uint32 srcRepNum = numCheckpoints[srcRep];
                uint256 srcRepOld = srcRepNum &gt; 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;
                uint256 srcRepNew = srcRepOld.sub(amount);
                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);
            }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre>        if (dstRep != address(0)) {
            // increase new representative
            uint32 dstRepNum = numCheckpoints\[dstRep\];
            uint256 dstRepOld = dstRepNum &gt; 0 ? checkpoints\[dstRep\]\[dstRepNum - 1\].votes : 0;
            uint256 dstRepNew = dstRepOld.add(amount);
            \_writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);
        }
    }
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>_writeCheckpoint The code is as follows , The parameters here are described as follows Ôºö</p>

<ul>
  <li>delegateeÔºö Accept token Address</li>
  <li>nCheckpointsÔºö Number of original checkpoints</li>
  <li>oldVotesÔºö Number of old votes</li>
  <li>newVotesÔºö Number of new votes</li>
</ul>

<p>Then get the current number of blocks , Then check whether the number of original checkpoints is greater than 0, Accept token Of the previous checkpoint corresponding to the address fromBlock Is it consistent with the current number of blocks , Update accepted if consistent token Voting of the previous checkpoint corresponding to the address , Otherwise, the update is accepted token The current check site of the address votes , At the same time, add the number of inspection sites 1, After through emit Triggering event , In general, coinage is accompanied by the recording and distribution of votes Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre>function \_writeCheckpoint(
    address delegatee,
    uint32 nCheckpoints,
    uint256 oldVotes,
    uint256 newVotes )
    internal {
    uint32 blockNumber = safe32(block.number, "SUSHI::\_writeCheckpoint: block number exceeds 32 bits");

    if (nCheckpoints &gt; 0 &amp;&amp; checkpoints\[delegatee\]\[nCheckpoints - 1\].fromBlock == blockNumber) {
        checkpoints\[delegatee\]\[nCheckpoints - 1\].votes = newVotes;
    } else {
        checkpoints\[delegatee\]\[nCheckpoints\] = Checkpoint(blockNumber, newVotes);
        numCheckpoints\[delegatee\] = nCheckpoints + 1;
    }

    emit DelegateVotesChanged(delegatee, oldVotes, newVotes);
}
function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {
    require(n &lt; 2\*\*32, errorMessage);
    return uint32(n);
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Here are some global variables defined , Some of them have been introduced to Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre>/// @notice A record of votes checkpoints for each account, by index   //  Voting checkpoint records for each account listed by index 
mapping (address =&gt; mapping (uint32 =&gt; Checkpoint)) public checkpoints;

/// @notice The number of checkpoints for each account   //   Checkpoints per account 
mapping (address =&gt; uint32) public numCheckpoints;

/// @notice The EIP-712 typehash for the contract's domain
bytes32 public constant DOMAIN\_TYPEHASH = keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)");

/// @notice The EIP-712 typehash for the delegation struct used by the contract
bytes32 public constant DELEGATION\_TYPEHASH = keccak256("Delegation(address delegatee,uint256 nonce,uint256 expiry)");

/// @notice A record of states for signing / validating signatures
//  Signature / Verify the status record of the signature 
mapping (address =&gt; uint) public nonces;
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Then there are two events Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre> /// @notice An event thats emitted when an account changes its delegate
event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);

/// @notice An event thats emitted when a delegate account's vote balance changes
event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);
</pre></td></tr></tbody></table></code></pre></div></div>

<p>After that delegates The function is used to vote for the function caller delegatorÔºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>/\*\*
 \* @notice Delegate votes from \`msg.sender\` to \`delegatee\`
 \* @param delegator The address to get delegatee for
 \*/
function delegates(address delegator)
    external
    view
    returns (address) {
    return \_delegates\[delegator\];
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>delegatee The function is also used to deliver the ticket of the function caller to the specified address , Different from the above, this function calls _moveDelegates Used to transfer delegates Ôºö</p>

<p>/**
    * @notice Delegate votes from `msg.sender` to `delegatee`
    * @param delegatee The address to delegate votes to
    */
    function delegate(address delegatee) external {
        return _delegate(msg.sender, delegatee);
    }
    function _delegate(address delegator, address delegatee)
        internal
{
        address currentDelegate = _delegates[delegator];
        uint256 delegatorBalance = balanceOf(delegator); // balance of underlying SUSHIs (not scaled);
        _delegates[delegator] = delegatee;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>    emit DelegateChanged(delegator, currentDelegate, delegatee);

    \_moveDelegates(currentDelegate, delegatee, delegatorBalance);
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>From the signatory to the authorized person‚Äôs representative to vote Ôºö</p>

<ul>
  <li>delegateeÔºö Address to which the vote will be delegated</li>
  <li>nonceÔºö Contract status required to match signature</li>
  <li>expiryÔºö Time when the expired signature expires</li>
  <li>vÔºö Signed recovery bytes</li>
  <li>rÔºöECDSA Signature pair r Half</li>
  <li>
    <p>sÔºö yes ECDSA Half of the signature pair</p>

    <p>/**
 * @notice Delegates votes from signatory to `delegatee`
 * @param delegatee The address to delegate votes to
 * @param nonce The contract state required to match the signature
 * @param expiry The time at which to expire the signature
 * @param v The recovery byte of the signature
 * @param r Half of the ECDSA signature pair
 * @param s Half of the ECDSA signature pair
 */
function delegateBySig(
    address delegatee,
    uint nonce,
    uint expiry,
    uint8 v,
    bytes32 r,
    bytes32 s
)
    external
{
    bytes32 domainSeparator = keccak256(
        abi.encode(
            DOMAIN_TYPEHASH,
            keccak256(bytes(name())),
            getChainId(),
            address(this)
        )
    );</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="rouge-code"><pre>bytes32 structHash = keccak256(
    abi.encode(
        DELEGATION\_TYPEHASH,
        delegatee,
        nonce,
        expiry
    )
);

bytes32 digest = keccak256(
    abi.encodePacked(
        "\\x19\\x01",
        domainSeparator,
        structHash
    )
);

address signatory = ecrecover(digest, v, r, s);
require(signatory != address(0), "SUSHI::delegateBySig: invalid signature");
require(nonce == nonces\[signatory\]++, "SUSHI::delegateBySig: invalid nonce");
require(now &lt;= expiry, "SUSHI::delegateBySig: signature expired");
return \_delegate(signatory, delegatee); }
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
</ul>

<p>getCurrentVotes Used to get the current vote Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre>/\*\*
 \* @notice Gets the current votes balance for \`account\`
 \* @param account The address to get votes balance
 \* @return The number of current votes for \`account\`
 \*/
function getCurrentVotes(address account)
    external
    view
    returns (uint256) {
    uint32 nCheckpoints = numCheckpoints\[account\];
    return nCheckpoints &gt; 0 ? checkpoints\[account\]\[nCheckpoints - 1\].votes : 0;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>getPriorVotes Function to determine the number of priority votes for an account starting with a block number Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="rouge-code"><pre>/\*\*
 \* @notice Determine the prior number of votes for an account as of a block number
 \* @dev Block number must be a finalized block or else this function will revert to prevent misinformation.
 \* @param account The address of the account to check
 \* @param blockNumber The block number to get the vote balance at
 \* @return The number of votes the account had as of the given block
 \*/
function getPriorVotes(address account, uint blockNumber)
    external
    view
    returns (uint256) {
    require(blockNumber &lt; block.number, "SUSHI::getPriorVotes: not yet determined");

    uint32 nCheckpoints = numCheckpoints\[account\];
    if (nCheckpoints == 0) {
        return 0;
    }

    // First check most recent balance
    if (checkpoints\[account\]\[nCheckpoints - 1\].fromBlock &lt;= blockNumber) {
        return checkpoints\[account\]\[nCheckpoints - 1\].votes;
    }

    // Next check implicit zero balance
    if (checkpoints\[account\]\[0\].fromBlock &gt; blockNumber) {
        return 0;
    }

    uint32 lower = 0;
    uint32 upper = nCheckpoints - 1;
    while (upper &gt; lower) {
        uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow
        Checkpoint memory cp = checkpoints\[account\]\[center\];
        if (cp.fromBlock == blockNumber) {
            return cp.votes;
        } else if (cp.fromBlock &lt; blockNumber) {
            lower = center;
        } else {
            upper = center - 1;
        }
    }
    return checkpoints\[account\]\[lower\].votes;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>getChainId The function retrieves the current getChainIdÔºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>function getChainId() internal pure returns (uint) {
    uint256 chainId;
    assembly { chainId := chainid() }
    return chainId;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<h5 id="masterchef"><strong>MasterChef</strong></h5>

<p>MasterChef The main purpose of the contract is to LPsTokens Deposit in SUSHI fram, The following is the official contract source code Ôºö</p>

<p>// SPDX-License-Identifier: MIT</p>

<p>pragma solidity 0.6.12;</p>

<p>import ‚Äú@openzeppelin/contracts/token/ERC20/IERC20.sol‚Äù;
import ‚Äú@openzeppelin/contracts/token/ERC20/SafeERC20.sol‚Äù;
import ‚Äú@openzeppelin/contracts/utils/EnumerableSet.sol‚Äù;
import ‚Äú@openzeppelin/contracts/math/SafeMath.sol‚Äù;
import ‚Äú@openzeppelin/contracts/access/Ownable.sol‚Äù;
import ‚Äú./SushiToken.sol‚Äù;</p>

<p>interface IMigratorChef {
    // Perform LP token migration from legacy UniswapV2 to SushiSwap.
    // Take the current LP token address and return the new LP token address.
    // Migrator should have full access to the caller‚Äôs LP token.
    // Return the new LP token address.
    //
    // XXX Migrator must have allowance access to UniswapV2 LP tokens.
    // SushiSwap must mint EXACTLY the same amount of SushiSwap LP tokens or
    // else something bad will happen. Traditional UniswapV2 does not
    // do that so be careful!
    function migrate(IERC20 token) external returns (IERC20);
}</p>

<p>// MasterChef is the master of Sushi. He can make Sushi and he is a fair guy.
//
// Note that it‚Äôs ownable and the owner wields tremendous power. The ownership
// will be transferred to a governance smart contract once SUSHI is sufficiently
// distributed and the community can show to govern itself.
//
// Have fun reading it. Hopefully it‚Äôs bug-free. God bless.
contract MasterChef is Ownable {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;
    // Info of each user.
    struct UserInfo {
        uint256 amount; // How many LP tokens the user has provided.
        uint256 rewardDebt; // Reward debt. See explanation below.
        //
        // We do some fancy math here. Basically, any point in time, the amount of SUSHIs
        // entitled to a user but is pending to be distributed is:
        //
        //   pending reward = (user.amount * pool.accSushiPerShare) - user.rewardDebt
        //
        // Whenever a user deposits or withdraws LP tokens to a pool. Here‚Äôs what happens:
        //   1. The pool‚Äôs `accSushiPerShare` (and `lastRewardBlock`) gets updated.
        //   2. User receives the pending reward sent to his/her address.
        //   3. User‚Äôs `amount` gets updated.
        //   4. User‚Äôs `rewardDebt` gets updated.
    }
    // Info of each pool.
    struct PoolInfo {
        IERC20 lpToken; // Address of LP token contract.
        uint256 allocPoint; // How many allocation points assigned to this pool. SUSHIs to distribute per block.
        uint256 lastRewardBlock; // Last block number that SUSHIs distribution occurs.
        uint256 accSushiPerShare; // Accumulated SUSHIs per share, times 1e12. See below.
    }
    // The SUSHI TOKEN!
    SushiToken public sushi;
    // Dev address.
    address public devaddr;
    // Block number when bonus SUSHI period ends.
    uint256 public bonusEndBlock;
    // SUSHI tokens created per block.
    uint256 public sushiPerBlock;
    // Bonus muliplier for early sushi makers.
    uint256 public constant BONUS_MULTIPLIER = 10;
    // The migrator contract. It has a lot of power. Can only be set through governance (owner).
    IMigratorChef public migrator;
    // Info of each pool.
    PoolInfo[] public poolInfo;
    // Info of each user that stakes LP tokens.
    mapping(uint256 =&gt; mapping(address =&gt; UserInfo)) public userInfo;
    // Total allocation poitns. Must be the sum of all allocation points in all pools.
    uint256 public totalAllocPoint = 0;
    // The block number when SUSHI mining starts.
    uint256 public startBlock;
    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);
    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);
    event EmergencyWithdraw(
        address indexed user,
        uint256 indexed pid,
        uint256 amount
    );</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
</pre></td><td class="rouge-code"><pre>constructor(
    SushiToken \_sushi,
    address \_devaddr,
    uint256 \_sushiPerBlock,
    uint256 \_startBlock,
    uint256 \_bonusEndBlock ) public {
    sushi = \_sushi;
    devaddr = \_devaddr;
    sushiPerBlock = \_sushiPerBlock;
    bonusEndBlock = \_bonusEndBlock;
    startBlock = \_startBlock;
}

function poolLength() external view returns (uint256) {
    return poolInfo.length;
}

// Add a new lp to the pool. Can only be called by the owner.
// XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.
function add(
    uint256 \_allocPoint,
    IERC20 \_lpToken,
    bool \_withUpdate ) public onlyOwner {
    if (\_withUpdate) {
        massUpdatePools();
    }
    uint256 lastRewardBlock =
        block.number &gt; startBlock ? block.number : startBlock;
    totalAllocPoint = totalAllocPoint.add(\_allocPoint);
    poolInfo.push(
        PoolInfo({
            lpToken: \_lpToken,
            allocPoint: \_allocPoint,
            lastRewardBlock: lastRewardBlock,
            accSushiPerShare: 0
        })
    );
}

// Update the given pool's SUSHI allocation point. Can only be called by the owner.
function set(
    uint256 \_pid,
    uint256 \_allocPoint,
    bool \_withUpdate ) public onlyOwner {
    if (\_withUpdate) {
        massUpdatePools();
    }
    totalAllocPoint = totalAllocPoint.sub(poolInfo\[\_pid\].allocPoint).add(
        \_allocPoint
    );
    poolInfo\[\_pid\].allocPoint = \_allocPoint;
}

// Set the migrator contract. Can only be called by the owner.
function setMigrator(IMigratorChef \_migrator) public onlyOwner {
    migrator = \_migrator;
}

// Migrate lp token to another lp contract. Can be called by anyone. We trust that migrator contract is good.
function migrate(uint256 \_pid) public {
    require(address(migrator) != address(0), "migrate: no migrator");
    PoolInfo storage pool = poolInfo\[\_pid\];
    IERC20 lpToken = pool.lpToken;
    uint256 bal = lpToken.balanceOf(address(this));
    lpToken.safeApprove(address(migrator), bal);
    IERC20 newLpToken = migrator.migrate(lpToken);
    require(bal == newLpToken.balanceOf(address(this)), "migrate: bad");
    pool.lpToken = newLpToken;
}

// Return reward multiplier over the given \_from to \_to block.
function getMultiplier(uint256 \_from, uint256 \_to)
    public
    view
    returns (uint256) {
    if (\_to &lt;= bonusEndBlock) {
        return \_to.sub(\_from).mul(BONUS\_MULTIPLIER);
    } else if (\_from &gt;= bonusEndBlock) {
        return \_to.sub(\_from);
    } else {
        return
            bonusEndBlock.sub(\_from).mul(BONUS\_MULTIPLIER).add(
                \_to.sub(bonusEndBlock)
            );
    }
}

// View function to see pending SUSHIs on frontend.
function pendingSushi(uint256 \_pid, address \_user)
    external
    view
    returns (uint256) {
    PoolInfo storage pool = poolInfo\[\_pid\];
    UserInfo storage user = userInfo\[\_pid\]\[\_user\];
    uint256 accSushiPerShare = pool.accSushiPerShare;
    uint256 lpSupply = pool.lpToken.balanceOf(address(this));
    if (block.number &gt; pool.lastRewardBlock &amp;&amp; lpSupply != 0) {
        uint256 multiplier =
            getMultiplier(pool.lastRewardBlock, block.number);
        uint256 sushiReward =
            multiplier.mul(sushiPerBlock).mul(pool.allocPoint).div(
                totalAllocPoint
            );
        accSushiPerShare = accSushiPerShare.add(
            sushiReward.mul(1e12).div(lpSupply)
        );
    }
    return user.amount.mul(accSushiPerShare).div(1e12).sub(user.rewardDebt);
}

// Update reward vairables for all pools. Be careful of gas spending!
function massUpdatePools() public {
    uint256 length = poolInfo.length;
    for (uint256 pid = 0; pid &lt; length; ++pid) {
        updatePool(pid);
    }
}

// Update reward variables of the given pool to be up-to-date.
function updatePool(uint256 \_pid) public {
    PoolInfo storage pool = poolInfo\[\_pid\];
    if (block.number &lt;= pool.lastRewardBlock) {
        return;
    }
    uint256 lpSupply = pool.lpToken.balanceOf(address(this));
    if (lpSupply == 0) {
        pool.lastRewardBlock = block.number;
        return;
    }
    uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);
    uint256 sushiReward =
        multiplier.mul(sushiPerBlock).mul(pool.allocPoint).div(
            totalAllocPoint
        );
    sushi.mint(devaddr, sushiReward.div(10));
    sushi.mint(address(this), sushiReward);
    pool.accSushiPerShare = pool.accSushiPerShare.add(
        sushiReward.mul(1e12).div(lpSupply)
    );
    pool.lastRewardBlock = block.number;
}

// Deposit LP tokens to MasterChef for SUSHI allocation.
function deposit(uint256 \_pid, uint256 \_amount) public {
    PoolInfo storage pool = poolInfo\[\_pid\];
    UserInfo storage user = userInfo\[\_pid\]\[msg.sender\];
    updatePool(\_pid);
    if (user.amount &gt; 0) {
        uint256 pending =
            user.amount.mul(pool.accSushiPerShare).div(1e12).sub(
                user.rewardDebt
            );
        safeSushiTransfer(msg.sender, pending);
    }
    pool.lpToken.safeTransferFrom(
        address(msg.sender),
        address(this),
        \_amount
    );
    user.amount = user.amount.add(\_amount);
    user.rewardDebt = user.amount.mul(pool.accSushiPerShare).div(1e12);
    emit Deposit(msg.sender, \_pid, \_amount);
}

// Withdraw LP tokens from MasterChef.
function withdraw(uint256 \_pid, uint256 \_amount) public {
    PoolInfo storage pool = poolInfo\[\_pid\];
    UserInfo storage user = userInfo\[\_pid\]\[msg.sender\];
    require(user.amount &gt;= \_amount, "withdraw: not good");
    updatePool(\_pid);
    uint256 pending =
        user.amount.mul(pool.accSushiPerShare).div(1e12).sub(
            user.rewardDebt
        );
    safeSushiTransfer(msg.sender, pending);
    user.amount = user.amount.sub(\_amount);
    user.rewardDebt = user.amount.mul(pool.accSushiPerShare).div(1e12);
    pool.lpToken.safeTransfer(address(msg.sender), \_amount);
    emit Withdraw(msg.sender, \_pid, \_amount);
}

// Withdraw without caring about rewards. EMERGENCY ONLY.
function emergencyWithdraw(uint256 \_pid) public {
    PoolInfo storage pool = poolInfo\[\_pid\];
    UserInfo storage user = userInfo\[\_pid\]\[msg.sender\];
    pool.lpToken.safeTransfer(address(msg.sender), user.amount);
    emit EmergencyWithdraw(msg.sender, \_pid, user.amount);
    user.amount = 0;
    user.rewardDebt = 0;
}

// Safe sushi transfer function, just in case if rounding error causes pool to not have enough SUSHIs.
function safeSushiTransfer(address \_to, uint256 \_amount) internal {
    uint256 sushiBal = sushi.balanceOf(address(this));
    if (\_amount &gt; sushiBal) {
        sushi.transfer(\_to, sushiBal);
    } else {
        sushi.transfer(\_to, \_amount);
    }
}

// Update dev address by the previous dev.
function dev(address \_devaddr) public {
    require(msg.sender == devaddr, "dev: wut?");
    devaddr = \_devaddr;
} }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The structure defined here UserInfo Used to store user information Ôºö</p>

<ul>
  <li>amountÔºö User owned LP tokens The number of</li>
  <li>rewardDebtÔºö A previous liability when the user calculates the reward</li>
</ul>

<p>there rewardDebt It can also be understood as liabilities , Because when everyone mortgages, the rewards in the pool may have begun to be distributed or accumulated , namely accSushiPerShare The value is increasing and changing , After each user is mortgaged, he can‚Äôt give all the previously accumulated rewards to him , Because he can‚Äôt generate rewards before he mortgages , So there is a debt , Deduct the reward generated by the whole pool before he mortgages from the total reward , From his mortgage , This is also the source of user reward calculation Ôºö</p>

<p>pending reward = (user.amount * pool.accSushiPerShare) - user.rewardDebt</p>

<p>At the same time, it can be seen from the annotation information that the user is accessing LP tokens when , In the pool accSushiPerShare„ÄÅlastRewardBlock„ÄÅrewardDebt And other information is changing Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre>// Info of each user.
struct UserInfo {
    uint256 amount; // How many LP tokens the user has provided.
    uint256 rewardDebt; // Reward debt. See explanation below.
    //
    // We do some fancy math here. Basically, any point in time, the amount of SUSHIs
    // entitled to a user but is pending to be distributed is:
    //
    //   pending reward = (user.amount \* pool.accSushiPerShare) - user.rewardDebt
    //
    // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:
    //   1. The pool's \`accSushiPerShare\` (and \`lastRewardBlock\`) gets updated.
    //   2. User receives the pending reward sent to his/her address.
    //   3. User's \`amount\` gets updated.
    //   4. User's \`rewardDebt\` gets updated.
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Structure defined here PoolInfo Used to store pool information Ôºö</p>

<ul>
  <li>lpTokenÔºöLP Token Contract address</li>
  <li>allocPointÔºö Pools are allocated from a single block SUSHIs The weight of</li>
  <li>lastRewardBlockÔºöSUSHIs The number of the last block distributed</li>
  <li>
    <p>accSushiPerShareÔºö When calculating mortgage mining, single LP The number of corresponding rewards that a token can get</p>

    <p>// Info of each pool.
struct PoolInfo {
    IERC20 lpToken; // Address of LP token contract.
    uint256 allocPoint; // How many allocation points assigned to this pool. SUSHIs to distribute per block.
    uint256 lastRewardBlock; // Last block number that SUSHIs distribution occurs.
    uint256 accSushiPerShare; // Accumulated SUSHIs per share, times 1e12. See below.
}</p>
  </li>
</ul>

<p>After that, the global variables used later are declared Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre>// The SUSHI TOKEN!
SushiToken public sushi;            //SUSHI Token Contract address 
// Dev address.
address public devaddr;              // Production environment address 
// Block number when bonus SUSHI period ends.
uint256 public bonusEndBlock;          // Reward SUSHI End time zone block number 
// SUSHI tokens created per block.
uint256 public sushiPerBlock;          // A block can be generated SUSHI Number 
// Bonus muliplier for early sushi makers.
uint256 public constant BONUS\_MULTIPLIER = 10;  // In the early sushi Reward double 
// The migrator contract. It has a lot of power. Can only be set through governance (owner).
IMigratorChef public migrator;          //migrator Contract address 
// Info of each pool.
PoolInfo\[\] public poolInfo;            // An array used to store ore pool information 
// Info of each user that stakes LP tokens.
mapping(uint256 =&gt; mapping(address =&gt; UserInfo)) public userInfo;   // User's mortgage LP Tokens Information about 
// Total allocation poitns. Must be the sum of all allocation points in all pools.
uint256 public totalAllocPoint = 0;            // Total distribution weight ( It must be the sum of the assigned weights of all pools )
// The block number when SUSHI mining starts.
uint256 public startBlock;            // The momentum block where mining began 
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The sum of defines related events Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre> // Storage    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);   // extract 
event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);    // Emergency withdrawal 
event EmergencyWithdraw(
    address indexed user,
    uint256 indexed pid,
    uint256 amount );
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The subsequent constructor initializes Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre>constructor(
    SushiToken \_sushi,
    address \_devaddr,
    uint256 \_sushiPerBlock,
    uint256 \_startBlock,
    uint256 \_bonusEndBlock
) public {
    sushi = \_sushi;
    devaddr = \_devaddr;
    sushiPerBlock = \_sushiPerBlock;
    bonusEndBlock = \_bonusEndBlock;
    startBlock = \_startBlock;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>poolLength Used to return the current number of pools Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>function poolLength() external view returns (uint256) {
    return poolInfo.length;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>add Function to add a pool , This function can only be used by the contract owner call , And three parameters need to be passed Ôºö</p>

<ul>
  <li>_allocPointÔºö Assign weights (_allocPoint/totalAllocPoint Assign‚Ä¶ To a single block of the current pool SUSHIs Total of )</li>
  <li>_lpTokenÔºöLP Tokens Contract address</li>
  <li>_withUpdateÔºö Update pool</li>
</ul>

<p>We‚Äôll check here first _withUpdate Boolean value , If true Then update the pool once , If false, Then retrieve the current number of last reward blocks , Then update the total allocated points , After that, the newly created pool information is stored Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre>// Add a new lp to the pool. Can only be called by the owner.
// XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.
function add(
    uint256 \_allocPoint,
    IERC20 \_lpToken,
    bool \_withUpdate ) public onlyOwner {
    if (\_withUpdate) {
        massUpdatePools();
    }
    uint256 lastRewardBlock =
        block.number &gt; startBlock ? block.number : startBlock;
    totalAllocPoint = totalAllocPoint.add(\_allocPoint);
    poolInfo.push(
        PoolInfo({
            lpToken: \_lpToken,
            allocPoint: \_allocPoint,
            lastRewardBlock: lastRewardBlock,
            accSushiPerShare: 0
        })
    );
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>set Function to update the in the pool SUSHI Assign points , This function can only be used by the contract owner call , Here you need to pass three parameters Ôºö</p>

<ul>
  <li>_pidÔºö Pool‚Äôs ID Sequence</li>
  <li>_allocPointÔºö Assign weights (_allocPoint/totalAllocPoint Assign‚Ä¶ To a single block of the current pool SUSHIs Total of )</li>
  <li>_withUpdateÔºö Whether to update</li>
</ul>

<p>Then check whether it is updated , If true Then update the pool once , If false, Through pid Retrieve the allocated points of the corresponding pool , The assigned points are updated later Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre>// Update the given pool's SUSHI allocation point. Can only be called by the owner.
function set(
    uint256 \_pid,
    uint256 \_allocPoint,
    bool \_withUpdate ) public onlyOwner {
    if (\_withUpdate) {
        massUpdatePools();
    }
    totalAllocPoint = totalAllocPoint.sub(poolInfo\[\_pid\].allocPoint).add(
        \_allocPoint
    );
    poolInfo\[\_pid\].allocPoint = \_allocPoint;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>setMigrator Functions can only be defined by contract owner call , Used for setting up migrate The address of the contract Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>// Set the migrator contract. Can only be called by the owner.
function setMigrator(IMigratorChef \_migrator) public onlyOwner {
    migrator = \_migrator;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>migrate The function is used to LP token Move to another one LP In contract , It will be checked here first migrator Whether the address is empty , Then according to pid Parameter to retrieve the corresponding pool information , Later retrieval LpToken Contract address , Query after LpToken Held by the current contract address in the contract LP Token Number , Then call LpToken The contract safeApprove The function returns the current contract address LP Tokens Operation authority authorized to migrator Contract address , Then call migrator The contract migrator Function , Then check LpToken The account corresponding to the current contract address in the contract Lp tokens Is it equal to the current newLpToken Held by the current contract account address in the contract LP Tokens Number , Finally, update the in the pool information lpToken Address</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre>// Migrate lp token to another lp contract. Can be called by anyone. We trust that migrator contract is good.
function migrate(uint256 \_pid) public {
    require(address(migrator) != address(0), "migrate: no migrator");
    PoolInfo storage pool = poolInfo\[\_pid\];
    IERC20 lpToken = pool.lpToken;
    uint256 bal = lpToken.balanceOf(address(this));
    lpToken.safeApprove(address(migrator), bal);
    IERC20 newLpToken = migrator.migrate(lpToken);
    require(bal == newLpToken.balanceOf(address(this)), "migrate: bad");
    pool.lpToken = newLpToken;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Now we‚Äôre right migrate Of migrate The method is analyzed , Look at the specific migration process , This will be passed in from above first lpToken The address of the contract is orig The value of the parameter , The relevant inspection here will not be repeated ( among chef„ÄÅnotBeforeBlock„ÄÅoldFactory Connect to Migrator The contract is initialized in the constructor , No discussion ), Then use token0 And token1 Store old LpToken Address information of transaction pair in , Then according to token0 and token1 Retrieve whether the corresponding transaction pair exists at present , If not, create a new one , Then use lp Storage LpToken Of function callers in contracts Lp Tokens Number , If at this time lp by 0, Then return directly pair, If lp Not for 0, Will lp Assign a value to desiredLiquidity, Then call LpToken In the contract transferFrom Function transfer lp To LpToken In the contract address , Then call LpToken Contract address burn The function extracts the corresponding two assets by burning liquidity tokens , And reduce the liquidity of transaction pairs accordingly , Finally, by calling the of the current transaction pair mint Function when the user provides mobility ( Provide a certain proportion of two ERC-20 Token to transaction pair ) Add liquidity tokens to liquidity providers and finally complete LP Migration , It should be noted that it must comply with UniswapV2 agreement Ôºö</p>

<p>// Migrator</p>

<p>// SPDX-License-Identifier: MIT</p>

<p>pragma solidity 0.6.12;</p>

<p>import ‚Äú./uniswapv2/interfaces/IUniswapV2Pair.sol‚Äù;
import ‚Äú./uniswapv2/interfaces/IUniswapV2Factory.sol‚Äù;</p>

<p>contract Migrator {
    address public chef;
    address public oldFactory;
    IUniswapV2Factory public factory;
    uint256 public notBeforeBlock;
    uint256 public desiredLiquidity = uint256(-1);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="rouge-code"><pre>constructor(
    address \_chef,
    address \_oldFactory,
    IUniswapV2Factory \_factory,
    uint256 \_notBeforeBlock
) public {
    chef = \_chef;
    oldFactory = \_oldFactory;
    factory = \_factory;
    notBeforeBlock = \_notBeforeBlock;
}

function migrate(IUniswapV2Pair orig) public returns (IUniswapV2Pair) {
    require(msg.sender == chef, "not from master chef");
    require(block.number &gt;= notBeforeBlock, "too early to migrate");
    require(orig.factory() == oldFactory, "not from old factory");
    address token0 = orig.token0();
    address token1 = orig.token1();
    IUniswapV2Pair pair = IUniswapV2Pair(factory.getPair(token0, token1));
    if (pair == IUniswapV2Pair(address(0))) {
        pair = IUniswapV2Pair(factory.createPair(token0, token1));
    }
    uint256 lp = orig.balanceOf(msg.sender);
    if (lp == 0) return pair;
    desiredLiquidity = lp;
    orig.transferFrom(msg.sender, address(orig), lp);
    orig.burn(address(pair));
    pair.mint(msg.sender);
    desiredLiquidity = uint256(-1);
    return pair;
} }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>getMultiplier Function to obtain the reward multiplier , First of all, I will check to Is the address less than SUSHI Number of blocks after a round , If yes, calculate to and from Difference between , Then multiply by BONUS_MULTIPLIER And back to , If to Greater than ,SUSHI Number of blocks after a round , Then check from Is it greater than SUSHI Number of blocks after a round , If yes, calculate to And from Difference between , Then return , If form Less than SUSHI Number of blocks after a round ,to Greater than SUSHI Number of blocks after a round , The calculation from And to Difference between , Then multiply by BONUS_MULTIPLIER, And then add to subtract SUSHI Number of blocks after a round Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre>// Return reward multiplier over the given \_from to \_to block.
function getMultiplier(uint256 \_from, uint256 \_to)
    public
    view
    returns (uint256) {
    if (\_to &lt;= bonusEndBlock) {
        return \_to.sub(\_from).mul(BONUS\_MULTIPLIER);
    } else if (\_from &gt;= bonusEndBlock) {
        return \_to.sub(\_from);
    } else {
        return
            bonusEndBlock.sub(\_from).mul(BONUS\_MULTIPLIER).add(
                \_to.sub(bonusEndBlock)
            );
    }
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>pendingSushi The function is used to retrieve information from a queue SUSHI, The function will first pid To retrieve the corresponding pool , Then according to pid and user Retrieve the user information in the corresponding pool ( Structure information storage ), Then retrieve the data in the pool accSushiPerShare, Then use lpSupply Storage LpToken What is the current contract address in the contract Lp Total amount , Then check whether the current number of blocks is greater than the last reward block in the pool and lpSupply Is it 0, Before calling getMultiplier To calculate the reward multiplier , Then multiply the reward product by a block SUSHI Tokens Number , Then multiply by the assigned weight of the pool ( Pool allocation points divided by total allocation points ), Then update accSushiPerShare( Use accSushiPerShare add sushiReward Then multiply by 1e12 And divide by lpSupply), Then use the information held by the user LpTokens Quantity times accSushiPerShare Then divide by 1e12, Then subtract user liabilities Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre>// View function to see pending SUSHIs on frontend.
function pendingSushi(uint256 \_pid, address \_user)
    external
    view
    returns (uint256)
{
    PoolInfo storage pool = poolInfo\[\_pid\];
    UserInfo storage user = userInfo\[\_pid\]\[\_user\];
    uint256 accSushiPerShare = pool.accSushiPerShare;
    uint256 lpSupply = pool.lpToken.balanceOf(address(this));
    if (block.number &gt; pool.lastRewardBlock &amp;&amp; lpSupply != 0) {
        uint256 multiplier =
            getMultiplier(pool.lastRewardBlock, block.number);
        uint256 sushiReward =
            multiplier.mul(sushiPerBlock).mul(pool.allocPoint).div(
                totalAllocPoint
            );
        accSushiPerShare = accSushiPerShare.add(
            sushiReward.mul(1e12).div(lpSupply)
        );
    }
    return user.amount.mul(accSushiPerShare).div(1e12).sub(user.rewardDebt);
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>massUpdatePools Used to update the reward pool , Here, first get the number of reward pools , Then update from the first reward pool , The update method is called directly updatePool function Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre>// Update reward vairables for all pools. Be careful of gas spending!
function massUpdatePools() public {
    uint256 length = poolInfo.length;
    for (uint256 pid = 0; pid &lt; length; ++pid) {
        updatePool(pid);
    }
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>updatePool Function is the specific implementation of updating the reward pool , First of all, according to pid To retrieve the corresponding pool information , Then check whether the current block number is less than the latest reward block in the pool , If yes, direct return, If it is larger than the latest reward block, retrieve LpTokens The corresponding to the current contract address in the contract address LP Total amount , If LP A total of 0, Then update the last reward block to the current number of blocks , If LP Not for 0, Call getMultiplier To calculate the reward multiplier , Calculated after sushiReward, Then call sushi The contract mint Function issuance sushiReward.div(10) Quantity of quantity SUSHI, This is also what the article said at the beginning ‚ÄúSushi Reserved for each distribution 10% Provide future development iteration and safety audit for the project ‚Äú, Then issue additional to the current contract address sushiReward In quantity SUSHI, The last update accSushiPerShare, And the most recent reward block .</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre>// Update reward variables of the given pool to be up-to-date.
function updatePool(uint256 \_pid) public {
    PoolInfo storage pool = poolInfo\[\_pid\];
    if (block.number &lt;= pool.lastRewardBlock) {
        return;
    }
    uint256 lpSupply = pool.lpToken.balanceOf(address(this));
    if (lpSupply == 0) {
        pool.lastRewardBlock = block.number;
        return;
    }
    uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);
    uint256 sushiReward =
        multiplier.mul(sushiPerBlock).mul(pool.allocPoint).div(
            totalAllocPoint
        );
    sushi.mint(devaddr, sushiReward.div(10));
    sushi.mint(address(this), sushiReward);
    pool.accSushiPerShare = pool.accSushiPerShare.add(
        sushiReward.mul(1e12).div(lpSupply)
    );
    pool.lastRewardBlock = block.number;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>deposit The function is used to LP token Pledge to MasterChef For convenience SUSHI Distribute , The function will first pid Retrieve the corresponding pool , Then according to pid and msg.sender Retrieve information about users in the pool , Then call updatePool Update the pool once , Then retrieve the information held by the user LP token Is it greater than 0, If it is greater than 0 Then calculate once pending Rewards during , The specific calculation method is to use the‚Ä¶ Held by the user LP token Number times the number in the pool accSushiPerShare, Then divide by 1e12, And minus the user‚Äôs incentive liabilities , Then call safeSushiTransfer send out pending In quantity SUSHI To msg.sender, Call later lpToken The contract safeTransferFrom Function will msg.sender In the address _amount In quantity LpToken Send to current contract , Then update the information held by the user LpToken Total amount , And the user‚Äôs debt reward , After through emit Triggering event Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre>// Deposit LP tokens to MasterChef for SUSHI allocation.
function deposit(uint256 \_pid, uint256 \_amount) public {
    PoolInfo storage pool = poolInfo\[\_pid\];
    UserInfo storage user = userInfo\[\_pid\]\[msg.sender\];
    updatePool(\_pid);
    if (user.amount &gt; 0) {
        uint256 pending =
            user.amount.mul(pool.accSushiPerShare).div(1e12).sub(
                user.rewardDebt
            );
        safeSushiTransfer(msg.sender, pending);
    }
    pool.lpToken.safeTransferFrom(
        address(msg.sender),
        address(this),
        \_amount
    );
    user.amount = user.amount.add(\_amount);
    user.rewardDebt = user.amount.mul(pool.accSushiPerShare).div(1e12);
    emit Deposit(msg.sender, \_pid, \_amount);
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>withdraw The function is used from MasterChef Extract from Lp Token, The function will first pid To retrieve the corresponding pool , Then according to pid and msg.sender To retrieve the corresponding user Information , Then check user Held by LP tokens Is it greater than the value to extract Lp tokens Number , Then update the pool , Then calculate once pending( Rewards obtained during queue , Because in withdraw and deposits There may be other users accessing , Lead to accSushiPerShare Wait for the change , There will also be rewards at this stage ), Then call safeSushiTransfer Send corresponding quantity SUSHI To msg.sender, Then update the information held by the user LPTokens Number , The incentive liability is then updated , Then call lpToken The contract safeTransfer Function first msg.sender The address to send amout In quantity LP tokens, Then call emit Triggering event .</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre>// Withdraw LP tokens from MasterChef.
function withdraw(uint256 \_pid, uint256 \_amount) public {
    PoolInfo storage pool = poolInfo\[\_pid\];
    UserInfo storage user = userInfo\[\_pid\]\[msg.sender\];
    require(user.amount &gt;= \_amount, "withdraw: not good");
    updatePool(\_pid);
    uint256 pending =
        user.amount.mul(pool.accSushiPerShare).div(1e12).sub(
            user.rewardDebt
        );
    safeSushiTransfer(msg.sender, pending);
    user.amount = user.amount.sub(\_amount);
    user.rewardDebt = user.amount.mul(pool.accSushiPerShare).div(1e12);
    pool.lpToken.safeTransfer(address(msg.sender), \_amount);
    emit Withdraw(msg.sender, \_pid, \_amount);
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>emergencyWithdraw For emergency withdrawal , First of all, according to pid Retrieve the corresponding pool , Then according to pid as well as msg.sender Address to retrieve user information , Then call LpToken The contract Safetransfer Function first msg.sender The address to send user.amount In quantity LP tokens, After through emit Triggering event , And update the information held by the user LP tokens Number of awards and liabilities .</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre>// Withdraw without caring about rewards. EMERGENCY ONLY.
function emergencyWithdraw(uint256 \_pid) public {
    PoolInfo storage pool = poolInfo\[\_pid\];
    UserInfo storage user = userInfo\[\_pid\]\[msg.sender\];
    pool.lpToken.safeTransfer(address(msg.sender), user.amount);
    emit EmergencyWithdraw(msg.sender, \_pid, user.amount);
    user.amount = 0;
    user.rewardDebt = 0;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>safeSushiTransfer A function is a simple SUSHI Transfer function , No more details here Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre>// Safe sushi transfer function, just in case if rounding error causes pool to not have enough SUSHIs.
function safeSushiTransfer(address \_to, uint256 \_amount) internal {
    uint256 sushiBal = sushi.balanceOf(address(this));
    if (\_amount &gt; sushiBal) {
        sushi.transfer(\_to, sushiBal);
    } else {
        sushi.transfer(\_to, \_amount);
    }
}
</pre></td></tr></tbody></table></code></pre></div></div>

<h5 id="masterchefv2"><strong>MasterChefV2</strong></h5>

<p>MasterChefV2 And MasterChef similar , I won‚Äôt go into that here ~</p>

<h5 id="migrator"><strong>Migrator</strong></h5>

<p>Migrator The role of the contract is mainly to support UniswapV2 Implementation in the pool of protocols LP The migration operation of , Because this part of the code has been carefully explained before , I won‚Äôt go into that here , If there are questions , You can turn it forward , Here is Migrator Source code Ôºö</p>

<p>// SPDX-License-Identifier: MIT</p>

<p>pragma solidity 0.6.12;</p>

<p>import ‚Äú./uniswapv2/interfaces/IUniswapV2Pair.sol‚Äù;
import ‚Äú./uniswapv2/interfaces/IUniswapV2Factory.sol‚Äù;</p>

<p>contract Migrator {
    address public chef;
    address public oldFactory;
    IUniswapV2Factory public factory;
    uint256 public notBeforeBlock;
    uint256 public desiredLiquidity = uint256(-1);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="rouge-code"><pre>constructor(
    address \_chef,
    address \_oldFactory,
    IUniswapV2Factory \_factory,
    uint256 \_notBeforeBlock
) public {
    chef = \_chef;
    oldFactory = \_oldFactory;
    factory = \_factory;
    notBeforeBlock = \_notBeforeBlock;
}

function migrate(IUniswapV2Pair orig) public returns (IUniswapV2Pair) {
    require(msg.sender == chef, "not from master chef");
    require(block.number &gt;= notBeforeBlock, "too early to migrate");
    require(orig.factory() == oldFactory, "not from old factory");
    address token0 = orig.token0();
    address token1 = orig.token1();
    IUniswapV2Pair pair = IUniswapV2Pair(factory.getPair(token0, token1));
    if (pair == IUniswapV2Pair(address(0))) {
        pair = IUniswapV2Pair(factory.createPair(token0, token1));
    }
    uint256 lp = orig.balanceOf(msg.sender);
    if (lp == 0) return pair;
    desiredLiquidity = lp;
    orig.transferFrom(msg.sender, address(orig), lp);
    orig.burn(address(pair));
    pair.mint(msg.sender);
    desiredLiquidity = uint256(-1);
    return pair;
} }
</pre></td></tr></tbody></table></code></pre></div></div>

<p><strong>Ownable</strong></p>

<p>Ownerable The contract is a supplementary extension contract , Mainly involves owner Initialization and owner Transfer of authority, etc , It‚Äôs simpler , No more details here , Here is the source code Ôºö</p>

<p>// SPDX-License-Identifier: MIT
// Audit on 5-Jan-2021 by Keno and BoringCrypto</p>

<p>// P1 - P3: OK
pragma solidity 0.6.12;</p>

<p>// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol
// Edited by BoringCrypto</p>

<p>// T1 - T4: OK
contract OwnableData {
    // V1 - V5: OK
    address public owner;
    // V1 - V5: OK
    address public pendingOwner;
}</p>

<p>// T1 - T4: OK
contract Ownable is OwnableData {
    // E1: OK
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="rouge-code"><pre>constructor () internal {
    owner = msg.sender;
    emit OwnershipTransferred(address(0), msg.sender);
}

// F1 - F9: OK
// C1 - C21: OK
function transferOwnership(address newOwner, bool direct, bool renounce) public onlyOwner {
    if (direct) {
        // Checks
        require(newOwner != address(0) || renounce, "Ownable: zero address");

        // Effects
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    } else {
        // Effects
        pendingOwner = newOwner;
    }
}

// F1 - F9: OK
// C1 - C21: OK
function claimOwnership() public {
    address \_pendingOwner = pendingOwner;

    // Checks
    require(msg.sender == \_pendingOwner, "Ownable: caller != pending owner");

    // Effects
    emit OwnershipTransferred(owner, \_pendingOwner);
    owner = \_pendingOwner;
    pendingOwner = address(0);
}

// M1 - M5: OK
// C1 - C21: OK
modifier onlyOwner() {
    require(msg.sender == owner, "Ownable: caller is not the owner");
    \_;
} }
</pre></td></tr></tbody></table></code></pre></div></div>

<h5 id="sushibar"><strong>SushiBar</strong></h5>

<p>SushiBar The main function of the contract is mortgage SUSHI To get more SUSHI, Users can mortgage first Sushi, Then get xSushi In return , Then put it in xSushi In the pool , When the user SushiSwap When trading on the exchange , Will charge 0.3ÔºÖ The cost of , Of this fee 0.05ÔºÖ With LP Add as token to SushiBar In the pool , When the award contract is invoked ( At least once a day ), all LP Tokens will be Sushi At the price of ( stay SushiSwap Exchange On ), Then the newly purchased SUSHI Prorated to in pool xSushi holder , It means their xSushi Now the value is higher . at present , Until withdrawal , You can see the increased amount , It was originally 1 individual SUSHI= 1 individual xSushi, But like LP Like tokens ,xSushi The price of will change over time , It depends on how much is in the pool SUSHI Reward , The following is the official source code Ôºö</p>

<p>// SPDX-License-Identifier: MIT</p>

<p>pragma solidity 0.6.12;</p>

<p>import ‚Äú@openzeppelin/contracts/token/ERC20/IERC20.sol‚Äù;
import ‚Äú@openzeppelin/contracts/token/ERC20/ERC20.sol‚Äù;
import ‚Äú@openzeppelin/contracts/math/SafeMath.sol‚Äù;</p>

<p>// SushiBar is the coolest bar in town. You come in with some Sushi, and leave with more! The longer you stay, the more Sushi you get.
//
// This contract handles swapping to and from xSushi, SushiSwap‚Äôs staking token.
contract SushiBar is ERC20(‚ÄúSushiBar‚Äù, ‚ÄúxSUSHI‚Äù){
    using SafeMath for uint256;
    IERC20 public sushi;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="rouge-code"><pre>// Define the Sushi token contract
constructor(IERC20 \_sushi) public {
    sushi = \_sushi;
}

// Enter the bar. Pay some SUSHIs. Earn some shares.
// Locks Sushi and mints xSushi
function enter(uint256 \_amount) public {
    // Gets the amount of Sushi locked in the contract
    uint256 totalSushi = sushi.balanceOf(address(this));
    // Gets the amount of xSushi in existence
    uint256 totalShares = totalSupply();
    // If no xSushi exists, mint it 1:1 to the amount put in
    if (totalShares == 0 || totalSushi == 0) {
        \_mint(msg.sender, \_amount);
    } 
    // Calculate and mint the amount of xSushi the Sushi is worth. The ratio will change overtime, as xSushi is burned/minted and Sushi deposited + gained from fees / withdrawn.
    else {
        uint256 what = \_amount.mul(totalShares).div(totalSushi);
        \_mint(msg.sender, what);
    }
    // Lock the Sushi in the contract
    sushi.transferFrom(msg.sender, address(this), \_amount);
}

// Leave the bar. Claim back your SUSHIs.
// Unlocks the staked + gained Sushi and burns xSushi
function leave(uint256 \_share) public {
    // Gets the amount of xSushi in existence
    uint256 totalShares = totalSupply();
    // Calculates the amount of Sushi the xSushi is worth
    uint256 what = \_share.mul(sushi.balanceOf(address(this))).div(totalShares);
    \_burn(msg.sender, \_share);
    sushi.transfer(msg.sender, what);
} }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Current contract inherited from ERC20 contract , And an initialization operation is carried out</p>

<p>contract SushiBar is ERC20(‚ÄúSushiBar‚Äù, ‚ÄúxSUSHI‚Äù){</p>

<p>Then initialize‚Ä¶ In the constructor SUSHI The address of the contract</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>// Define the Sushi token contract
constructor(IERC20 \_sushi) public {
    sushi = \_sushi;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>there enter Function for locking sushi And casting Xsushi, Here, we will first check the‚Ä¶ In the current contract sushi Total amount , Then calculate once xSushi Total amount , If l The total amount of any of the above two is 0, Call _mint Functions in accordance with the 1:1 Proportional coinage , If neither is 0 Then calculate the additional shares to be issued Xsushi Total amount , And call mint Additional issuance Xsushi, Then call sushi Of transferfrom Function to inject‚Ä¶ Into the current contract address sushiÔºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre>// Enter the bar. Pay some SUSHIs. Earn some shares.
// Locks Sushi and mints xSushi
function enter(uint256 \_amount) public {
    // Gets the amount of Sushi locked in the contract
    uint256 totalSushi = sushi.balanceOf(address(this));
    // Gets the amount of xSushi in existence
    uint256 totalShares = totalSupply();
    // If no xSushi exists, mint it 1:1 to the amount put in
    if (totalShares == 0 || totalSushi == 0) {
        \_mint(msg.sender, \_amount);
    } 
    // Calculate and mint the amount of xSushi the Sushi is worth. The ratio will change overtime, as xSushi is burned/minted and Sushi deposited + gained from fees / withdrawn.
    else {
        uint256 what = \_amount.mul(totalShares).div(totalSushi);
        \_mint(msg.sender, what);
    }
    // Lock the Sushi in the contract
    sushi.transferFrom(msg.sender, address(this), \_amount);
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>there leave Function to unlock and extract Sushi And destroy Xsushi, The function is completely opposite to the function above , Here we first calculate xSushi Total amount , Then calculate the current xSushi How much can it be worth Sushi, And then destroy xSushi And extract Sushi</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>// Leave the bar. Claim back your SUSHIs.
// Unlocks the staked + gained Sushi and burns xSushi
function leave(uint256 \_share) public {
    // Gets the amount of xSushi in existence
    uint256 totalShares = totalSupply();
    // Calculates the amount of Sushi the xSushi is worth
    uint256 what = \_share.mul(sushi.balanceOf(address(this))).div(totalShares);
    \_burn(msg.sender, \_share);
    sushi.transfer(msg.sender, what);
}
</pre></td></tr></tbody></table></code></pre></div></div>

<h5 id="sushimaker"><strong>SushiMaker</strong></h5>

<p>SushiMaker Role conversion of contract Token by SUSHI And send it to SushiBar, The official source code is as follows Ôºö</p>

<p>// SPDX-License-Identifier: MIT</p>

<p>// P1 - P3: OK
pragma solidity 0.6.12;
import ‚Äú./libraries/SafeMath.sol‚Äù;
import ‚Äú./libraries/SafeERC20.sol‚Äù;</p>

<p>import ‚Äú./uniswapv2/interfaces/IUniswapV2ERC20.sol‚Äù;
import ‚Äú./uniswapv2/interfaces/IUniswapV2Pair.sol‚Äù;
import ‚Äú./uniswapv2/interfaces/IUniswapV2Factory.sol‚Äù;</p>

<p>import ‚Äú./Ownable.sol‚Äù;</p>

<p>// SushiMaker is MasterChef‚Äôs left hand and kinda a wizard. He can cook up Sushi from pretty much anything!
// This contract handles ‚Äúserving up‚Äù rewards for xSushi holders by trading tokens collected from fees for Sushi.</p>

<p>// T1 - T4: OK
contract SushiMaker is Ownable {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
</pre></td><td class="rouge-code"><pre>// V1 - V5: OK
IUniswapV2Factory public immutable factory;
//0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac
// V1 - V5: OK
address public immutable bar;
//0x8798249c2E607446EfB7Ad49eC89dD1865Ff4272
// V1 - V5: OK
address private immutable sushi;
//0x6B3595068778DD592e39A122f4f5a5cF09C90fE2
// V1 - V5: OK
address private immutable weth;
//0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2

// V1 - V5: OK
mapping(address =&gt; address) internal \_bridges;

// E1: OK
event LogBridgeSet(address indexed token, address indexed bridge);
// E1: OK
event LogConvert(
    address indexed server,
    address indexed token0,
    address indexed token1,
    uint256 amount0,
    uint256 amount1,
    uint256 amountSUSHI
);

constructor(
    address \_factory,
    address \_bar,
    address \_sushi,
    address \_weth
) public {
    factory = IUniswapV2Factory(\_factory);
    bar = \_bar;
    sushi = \_sushi;
    weth = \_weth;
}

// F1 - F10: OK
// C1 - C24: OK
function bridgeFor(address token) public view returns (address bridge) {
    bridge = \_bridges\[token\];
    if (bridge == address(0)) {
        bridge = weth;
    }
}

// F1 - F10: OK
// C1 - C24: OK
function setBridge(address token, address bridge) external onlyOwner {
    // Checks
    require(
        token != sushi &amp;&amp; token != weth &amp;&amp; token != bridge,
        "SushiMaker: Invalid bridge"
    );

    // Effects
    \_bridges\[token\] = bridge;
    emit LogBridgeSet(token, bridge);
}

// M1 - M5: OK
// C1 - C24: OK
// C6: It's not a fool proof solution, but it prevents flash loans, so here it's ok to use tx.origin
modifier onlyEOA() {
    // Try to make flash-loan exploit harder to do by only allowing externally owned addresses.
    require(msg.sender == tx.origin, "SushiMaker: must use EOA");
    \_;
}

// F1 - F10: OK
// F3: \_convert is separate to save gas by only checking the 'onlyEOA' modifier once in case of convertMultiple
// F6: There is an exploit to add lots of SUSHI to the bar, run convert, then remove the SUSHI again.
//     As the size of the SushiBar has grown, this requires large amounts of funds and isn't super profitable anymore
//     The onlyEOA modifier prevents this being done with a flash loan.
// C1 - C24: OK
function convert(address token0, address token1) external onlyEOA() {
    \_convert(token0, token1);
}

// F1 - F10: OK, see convert
// C1 - C24: OK
// C3: Loop is under control of the caller
function convertMultiple(
    address\[\] calldata token0,
    address\[\] calldata token1 ) external onlyEOA() {
    // TODO: This can be optimized a fair bit, but this is safer and simpler for now
    uint256 len = token0.length;
    for (uint256 i = 0; i &lt; len; i++) {
        \_convert(token0\[i\], token1\[i\]);
    }
}

// F1 - F10: OK
// C1- C24: OK
function \_convert(address token0, address token1) internal {
    // Interactions
    // S1 - S4: OK
    IUniswapV2Pair pair = IUniswapV2Pair(factory.getPair(token0, token1));
    require(address(pair) != address(0), "SushiMaker: Invalid pair");
    // balanceOf: S1 - S4: OK
    // transfer: X1 - X5: OK
    IERC20(address(pair)).safeTransfer(
        address(pair),
        pair.balanceOf(address(this))
    );
    // X1 - X5: OK
    (uint256 amount0, uint256 amount1) = pair.burn(address(this));
    if (token0 != pair.token0()) {
        (amount0, amount1) = (amount1, amount0);
    }
    emit LogConvert(
        msg.sender,
        token0,
        token1,
        amount0,
        amount1,
        \_convertStep(token0, token1, amount0, amount1)
    );
}

// F1 - F10: OK
// C1 - C24: OK
// All safeTransfer, \_swap, \_toSUSHI, \_convertStep: X1 - X5: OK
function \_convertStep(
    address token0,
    address token1,
    uint256 amount0,
    uint256 amount1 ) internal returns (uint256 sushiOut) {
    // Interactions
    if (token0 == token1) {
        uint256 amount = amount0.add(amount1);
        if (token0 == sushi) {
            IERC20(sushi).safeTransfer(bar, amount);
            sushiOut = amount;
        } else if (token0 == weth) {
            sushiOut = \_toSUSHI(weth, amount);
        } else {
            address bridge = bridgeFor(token0);
            amount = \_swap(token0, bridge, amount, address(this));
            sushiOut = \_convertStep(bridge, bridge, amount, 0);
        }
    } else if (token0 == sushi) {
        // eg. SUSHI - ETH
        IERC20(sushi).safeTransfer(bar, amount0);
        sushiOut = \_toSUSHI(token1, amount1).add(amount0);
    } else if (token1 == sushi) {
        // eg. USDT - SUSHI
        IERC20(sushi).safeTransfer(bar, amount1);
        sushiOut = \_toSUSHI(token0, amount0).add(amount1);
    } else if (token0 == weth) {
        // eg. ETH - USDC
        sushiOut = \_toSUSHI(
            weth,
            \_swap(token1, weth, amount1, address(this)).add(amount0)
        );
    } else if (token1 == weth) {
        // eg. USDT - ETH
        sushiOut = \_toSUSHI(
            weth,
            \_swap(token0, weth, amount0, address(this)).add(amount1)
        );
    } else {
        // eg. MIC - USDT
        address bridge0 = bridgeFor(token0);
        address bridge1 = bridgeFor(token1);
        if (bridge0 == token1) {
            // eg. MIC - USDT - and bridgeFor(MIC) = USDT
            sushiOut = \_convertStep(
                bridge0,
                token1,
                \_swap(token0, bridge0, amount0, address(this)),
                amount1
            );
        } else if (bridge1 == token0) {
            // eg. WBTC - DSD - and bridgeFor(DSD) = WBTC
            sushiOut = \_convertStep(
                token0,
                bridge1,
                amount0,
                \_swap(token1, bridge1, amount1, address(this))
            );
        } else {
            sushiOut = \_convertStep(
                bridge0,
                bridge1, // eg. USDT - DSD - and bridgeFor(DSD) = WBTC
                \_swap(token0, bridge0, amount0, address(this)),
                \_swap(token1, bridge1, amount1, address(this))
            );
        }
    }
}

// F1 - F10: OK
// C1 - C24: OK
// All safeTransfer, swap: X1 - X5: OK
function \_swap(
    address fromToken,
    address toToken,
    uint256 amountIn,
    address to ) internal returns (uint256 amountOut) {
    // Checks
    // X1 - X5: OK
    IUniswapV2Pair pair =
        IUniswapV2Pair(factory.getPair(fromToken, toToken));
    require(address(pair) != address(0), "SushiMaker: Cannot convert");

    // Interactions
    // X1 - X5: OK
    (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();
    uint256 amountInWithFee = amountIn.mul(997);
    if (fromToken == pair.token0()) {
        amountOut =
            amountIn.mul(997).mul(reserve1) /
            reserve0.mul(1000).add(amountInWithFee);
        IERC20(fromToken).safeTransfer(address(pair), amountIn);
        pair.swap(0, amountOut, to, new bytes(0));
        // TODO: Add maximum slippage?
    } else {
        amountOut =
            amountIn.mul(997).mul(reserve0) /
            reserve1.mul(1000).add(amountInWithFee);
        IERC20(fromToken).safeTransfer(address(pair), amountIn);
        pair.swap(amountOut, 0, to, new bytes(0));
        // TODO: Add maximum slippage?
    }
}

// F1 - F10: OK
// C1 - C24: OK
function \_toSUSHI(address token, uint256 amountIn)
    internal
    returns (uint256 amountOut) {
    // X1 - X5: OK
    amountOut = \_swap(token, sushi, amountIn, bar);
} }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The constructor here directly initializes UniswapV2 Address of factory contract „ÄÅbar The address of the contract „ÄÅSUSHI The address of the contract „ÄÅWETH The address of the contract Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre>constructor(
    address \_factory,
    address \_bar,
    address \_sushi,
    address \_weth
) public {
    factory = IUniswapV2Factory(\_factory);
    bar = \_bar;
    sushi = \_sushi;
    weth = \_weth;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>bridgeFor Function to retrieve a token The bridge , If not set, the default is WETHÔºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>// F1 - F10: OK
// C1 - C24: OK
function bridgeFor(address token) public view returns (address bridge) {
    bridge = \_bridges\[token\];
    if (bridge == address(0)) {
        bridge = weth;
    }
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>setBridge Used to set a token The bridge Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre>// F1 - F10: OK
// C1 - C24: OK
function setBridge(address token, address bridge) external onlyOwner {
    // Checks
    require(
        token != sushi &amp;&amp; token != weth &amp;&amp; token != bridge,
        "SushiMaker: Invalid bridge"
    );

    // Effects
    \_bridges\[token\] = bridge;
    emit LogBridgeSet(token, bridge);
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Must be invoked using an external account Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>// M1 - M5: OK
// C1 - C24: OK
// C6: It's not a fool proof solution, but it prevents flash loans, so here it's ok to use tx.origin
modifier onlyEOA() {
    // Try to make flash-loan exploit harder to do by only allowing externally owned addresses.
    require(msg.sender == tx.origin, "SushiMaker: must use EOA");
    \_;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Conversion between two tokens Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
</pre></td><td class="rouge-code"><pre>// F1 - F10: OK
// F3: \_convert is separate to save gas by only checking the 'onlyEOA' modifier once in case of convertMultiple
// F6: There is an exploit to add lots of SUSHI to the bar, run convert, then remove the SUSHI again.
//     As the size of the SushiBar has grown, this requires large amounts of funds and isn't super profitable anymore
//     The onlyEOA modifier prevents this being done with a flash loan.
// C1 - C24: OK
function convert(address token0, address token1) external onlyEOA() {
    \_convert(token0, token1);
}

// F1 - F10: OK
// C1- C24: OK
function \_convert(address token0, address token1) internal {
    // Interactions
    // S1 - S4: OK
    IUniswapV2Pair pair = IUniswapV2Pair(factory.getPair(token0, token1));
    require(address(pair) != address(0), "SushiMaker: Invalid pair");
    // balanceOf: S1 - S4: OK
    // transfer: X1 - X5: OK
    IERC20(address(pair)).safeTransfer(
        address(pair),
        pair.balanceOf(address(this))
    );
    // X1 - X5: OK
    (uint256 amount0, uint256 amount1) = pair.burn(address(this));
    if (token0 != pair.token0()) {
        (amount0, amount1) = (amount1, amount0);
    }
    emit LogConvert(
        msg.sender,
        token0,
        token1,
        amount0,
        amount1,
        \_convertStep(token0, token1, amount0, amount1)
    );
}
// F1 - F10: OK
// C1 - C24: OK
// All safeTransfer, \_swap, \_toSUSHI, \_convertStep: X1 - X5: OK
function \_convertStep(
    address token0,
    address token1,
    uint256 amount0,
    uint256 amount1 ) internal returns (uint256 sushiOut) {
    // Interactions
    if (token0 == token1) {
        uint256 amount = amount0.add(amount1);
        if (token0 == sushi) {
            IERC20(sushi).safeTransfer(bar, amount);
            sushiOut = amount;
        } else if (token0 == weth) {
            sushiOut = \_toSUSHI(weth, amount);
        } else {
            address bridge = bridgeFor(token0);
            amount = \_swap(token0, bridge, amount, address(this));
            sushiOut = \_convertStep(bridge, bridge, amount, 0);
        }
    } else if (token0 == sushi) {
        // eg. SUSHI - ETH
        IERC20(sushi).safeTransfer(bar, amount0);
        sushiOut = \_toSUSHI(token1, amount1).add(amount0);
    } else if (token1 == sushi) {
        // eg. USDT - SUSHI
        IERC20(sushi).safeTransfer(bar, amount1);
        sushiOut = \_toSUSHI(token0, amount0).add(amount1);
    } else if (token0 == weth) {
        // eg. ETH - USDC
        sushiOut = \_toSUSHI(
            weth,
            \_swap(token1, weth, amount1, address(this)).add(amount0)
        );
    } else if (token1 == weth) {
        // eg. USDT - ETH
        sushiOut = \_toSUSHI(
            weth,
            \_swap(token0, weth, amount0, address(this)).add(amount1)
        );
    } else {
        // eg. MIC - USDT
        address bridge0 = bridgeFor(token0);
        address bridge1 = bridgeFor(token1);
        if (bridge0 == token1) {
            // eg. MIC - USDT - and bridgeFor(MIC) = USDT
            sushiOut = \_convertStep(
                bridge0,
                token1,
                \_swap(token0, bridge0, amount0, address(this)),
                amount1
            );
        } else if (bridge1 == token0) {
            // eg. WBTC - DSD - and bridgeFor(DSD) = WBTC
            sushiOut = \_convertStep(
                token0,
                bridge1,
                amount0,
                \_swap(token1, bridge1, amount1, address(this))
            );
        } else {
            sushiOut = \_convertStep(
                bridge0,
                bridge1, // eg. USDT - DSD - and bridgeFor(DSD) = WBTC
                \_swap(token0, bridge0, amount0, address(this)),
                \_swap(token1, bridge1, amount1, address(this))
            );
        }
    }
}
// F1 - F10: OK
// C1 - C24: OK
// All safeTransfer, swap: X1 - X5: OK
function \_swap(
    address fromToken,
    address toToken,
    uint256 amountIn,
    address to ) internal returns (uint256 amountOut) {
    // Checks
    // X1 - X5: OK
    IUniswapV2Pair pair =
        IUniswapV2Pair(factory.getPair(fromToken, toToken));
    require(address(pair) != address(0), "SushiMaker: Cannot convert");

    // Interactions
    // X1 - X5: OK
    (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();
    uint256 amountInWithFee = amountIn.mul(997);
    if (fromToken == pair.token0()) {
        amountOut =
            amountIn.mul(997).mul(reserve1) /
            reserve0.mul(1000).add(amountInWithFee);
        IERC20(fromToken).safeTransfer(address(pair), amountIn);
        pair.swap(0, amountOut, to, new bytes(0));
        // TODO: Add maximum slippage?
    } else {
        amountOut =
            amountIn.mul(997).mul(reserve0) /
            reserve1.mul(1000).add(amountInWithFee);
        IERC20(fromToken).safeTransfer(address(pair), amountIn);
        pair.swap(amountOut, 0, to, new bytes(0));
        // TODO: Add maximum slippage?
    }
}
// F1 - F10: OK
// C1 - C24: OK
function \_toSUSHI(address token, uint256 amountIn)
    internal
    returns (uint256 amountOut) {
    // X1 - X5: OK
    amountOut = \_swap(token, sushi, amountIn, bar);
}
</pre></td></tr></tbody></table></code></pre></div></div>

<h5 id="sushiroll"><strong>SushiRoll</strong></h5>

<p>SushiRoll Help you transfer existing Uniswap LP Token migration to SushiSwap LP token , The official source code is shown below Ôºö</p>

<p>// SPDX-License-Identifier: MIT</p>

<p>pragma solidity 0.6.12;</p>

<p>import ‚Äú@openzeppelin/contracts/token/ERC20/IERC20.sol‚Äù;
import ‚Äú@openzeppelin/contracts/token/ERC20/SafeERC20.sol‚Äù;
import ‚Äú./uniswapv2/interfaces/IUniswapV2Pair.sol‚Äù;
import ‚Äú./uniswapv2/interfaces/IUniswapV2Router01.sol‚Äù;
import ‚Äú./uniswapv2/interfaces/IUniswapV2Factory.sol‚Äù;
import ‚Äú./uniswapv2/libraries/UniswapV2Library.sol‚Äù;</p>

<p>// SushiRoll helps your migrate your existing Uniswap LP tokens to SushiSwap LP ones
contract SushiRoll {
    using SafeERC20 for IERC20;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
</pre></td><td class="rouge-code"><pre>IUniswapV2Router01 public oldRouter;
IUniswapV2Router01 public router;

constructor(IUniswapV2Router01 \_oldRouter, IUniswapV2Router01 \_router) public {
    oldRouter = \_oldRouter;
    router = \_router;
}

function migrateWithPermit(
    address tokenA,
    address tokenB,
    uint256 liquidity,
    uint256 amountAMin,
    uint256 amountBMin,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s ) public {
    IUniswapV2Pair pair = IUniswapV2Pair(pairForOldRouter(tokenA, tokenB));
    pair.permit(msg.sender, address(this), liquidity, deadline, v, r, s);

    migrate(tokenA, tokenB, liquidity, amountAMin, amountBMin, deadline);
}

// msg.sender should have approved 'liquidity' amount of LP token of 'tokenA' and 'tokenB'
function migrate(
    address tokenA,
    address tokenB,
    uint256 liquidity,
    uint256 amountAMin,
    uint256 amountBMin,
    uint256 deadline ) public {
    require(deadline &gt;= block.timestamp, 'SushiSwap: EXPIRED');

    // Remove liquidity from the old router with permit
    (uint256 amountA, uint256 amountB) = removeLiquidity(
        tokenA,
        tokenB,
        liquidity,
        amountAMin,
        amountBMin,
        deadline
    );

    // Add liquidity to the new router
    (uint256 pooledAmountA, uint256 pooledAmountB) = addLiquidity(tokenA, tokenB, amountA, amountB);

    // Send remaining tokens to msg.sender
    if (amountA &gt; pooledAmountA) {
        IERC20(tokenA).safeTransfer(msg.sender, amountA - pooledAmountA);
    }
    if (amountB &gt; pooledAmountB) {
        IERC20(tokenB).safeTransfer(msg.sender, amountB - pooledAmountB);
    }
}

function removeLiquidity(
    address tokenA,
    address tokenB,
    uint256 liquidity,
    uint256 amountAMin,
    uint256 amountBMin,
    uint256 deadline ) internal returns (uint256 amountA, uint256 amountB) {
    IUniswapV2Pair pair = IUniswapV2Pair(pairForOldRouter(tokenA, tokenB));
    pair.transferFrom(msg.sender, address(pair), liquidity);
    (uint256 amount0, uint256 amount1) = pair.burn(address(this));
    (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);
    (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);
    require(amountA &gt;= amountAMin, 'SushiRoll: INSUFFICIENT\_A\_AMOUNT');
    require(amountB &gt;= amountBMin, 'SushiRoll: INSUFFICIENT\_B\_AMOUNT');
}

// calculates the CREATE2 address for a pair without making any external calls
function pairForOldRouter(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = UniswapV2Library.sortTokens(tokenA, tokenB);
    pair = address(uint(keccak256(abi.encodePacked(
            hex'ff',
            oldRouter.factory(),
            keccak256(abi.encodePacked(token0, token1)),
            hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash
        ))));
}

function addLiquidity(
    address tokenA,
    address tokenB,
    uint256 amountADesired,
    uint256 amountBDesired ) internal returns (uint amountA, uint amountB) {
    (amountA, amountB) = \_addLiquidity(tokenA, tokenB, amountADesired, amountBDesired);
    address pair = UniswapV2Library.pairFor(router.factory(), tokenA, tokenB);
    IERC20(tokenA).safeTransfer(pair, amountA);
    IERC20(tokenB).safeTransfer(pair, amountB);
    IUniswapV2Pair(pair).mint(msg.sender);
}

function \_addLiquidity(
    address tokenA,
    address tokenB,
    uint256 amountADesired,
    uint256 amountBDesired ) internal returns (uint256 amountA, uint256 amountB) {
    // create the pair if it doesn't exist yet
    IUniswapV2Factory factory = IUniswapV2Factory(router.factory());
    if (factory.getPair(tokenA, tokenB) == address(0)) {
        factory.createPair(tokenA, tokenB);
    }
    (uint256 reserveA, uint256 reserveB) = UniswapV2Library.getReserves(address(factory), tokenA, tokenB);
    if (reserveA == 0 &amp;&amp; reserveB == 0) {
        (amountA, amountB) = (amountADesired, amountBDesired);
    } else {
        uint256 amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);
        if (amountBOptimal &lt;= amountBDesired) {
            (amountA, amountB) = (amountADesired, amountBOptimal);
        } else {
            uint256 amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);
            assert(amountAOptimal &lt;= amountADesired);
            (amountA, amountB) = (amountAOptimal, amountBDesired);
        }
    }
} }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Constructor initializes the old UniswapV2Router Address and new UniswapV2Router Address Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>constructor(IUniswapV2Router01 \_oldRouter, IUniswapV2Router01 \_router) public {
    oldRouter = \_oldRouter;
    router = \_router;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>migrateWithPermit Function to retrieve whether a transaction pair exists , Then call the transaction to the contract. permit Function to perform authorization operations , Last call migrate Migration Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre></td><td class="rouge-code"><pre>function migrateWithPermit(
    address tokenA,
    address tokenB,
    uint256 liquidity,
    uint256 amountAMin,
    uint256 amountBMin,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
) public {
    IUniswapV2Pair pair = IUniswapV2Pair(pairForOldRouter(tokenA, tokenB));
    pair.permit(msg.sender, address(this), liquidity, deadline, v, r, s);

    migrate(tokenA, tokenB, liquidity, amountAMin, amountBMin, deadline);
}

// msg.sender should have approved 'liquidity' amount of LP token of 'tokenA' and 'tokenB'
function migrate(
    address tokenA,
    address tokenB,
    uint256 liquidity,
    uint256 amountAMin,
    uint256 amountBMin,
    uint256 deadline
) public {
    require(deadline &gt;= block.timestamp, 'SushiSwap: EXPIRED');

    // Remove liquidity from the old router with permit
    (uint256 amountA, uint256 amountB) = removeLiquidity(
        tokenA,
        tokenB,
        liquidity,
        amountAMin,
        amountBMin,
        deadline
    );

    // Add liquidity to the new router
    (uint256 pooledAmountA, uint256 pooledAmountB) = addLiquidity(tokenA, tokenB, amountA, amountB);

    // Send remaining tokens to msg.sender
    if (amountA &gt; pooledAmountA) {
        IERC20(tokenA).safeTransfer(msg.sender, amountA - pooledAmountA);
    }
    if (amountB &gt; pooledAmountB) {
        IERC20(tokenB).safeTransfer(msg.sender, amountB - pooledAmountB);
    }
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>removeLiquidity Used to remove liquidity , After that, the liquidity token to be burned is transferred back to the transaction to the contract , Then the transaction pair is called. burn The function burns the liquidity tokens that fall in , Then extract the corresponding two tokens to the receiver , Then sort it out , Then perform the assignment operation , Then check whether the extracted corresponding token is greater than the minimum number of extracted tokens Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre>function removeLiquidity(
    address tokenA,
    address tokenB,
    uint256 liquidity,
    uint256 amountAMin,
    uint256 amountBMin,
    uint256 deadline ) internal returns (uint256 amountA, uint256 amountB) {
    IUniswapV2Pair pair = IUniswapV2Pair(pairForOldRouter(tokenA, tokenB));
    pair.transferFrom(msg.sender, address(pair), liquidity);
    (uint256 amount0, uint256 amount1) = pair.burn(address(this));
    (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);
    (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);
    require(amountA &gt;= amountAMin, 'SushiRoll: INSUFFICIENT\_A\_AMOUNT');
    require(amountB &gt;= amountBMin, 'SushiRoll: INSUFFICIENT\_B\_AMOUNT');
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// UniswapV2Pair.sol
    // this low-level function should be called from a contract which performs important safety checks
    function burn(address to) external lock returns (uint amount0, uint amount1) {
        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
        address _token0 = token0;                                // gas savings
        address _token1 = token1;                                // gas savings
        uint balance0 = IERC20Uniswap(_token0).balanceOf(address(this));
        uint balance1 = IERC20Uniswap(_token1).balanceOf(address(this));
        uint liquidity = balanceOf[address(this)];</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre>    bool feeOn = \_mintFee(\_reserve0, \_reserve1);
    uint \_totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in \_mintFee
    amount0 = liquidity.mul(balance0) / \_totalSupply; // using balances ensures pro-rata distribution
    amount1 = liquidity.mul(balance1) / \_totalSupply; // using balances ensures pro-rata distribution
    require(amount0 &gt; 0 &amp;&amp; amount1 &gt; 0, 'UniswapV2: INSUFFICIENT\_LIQUIDITY\_BURNED');
    \_burn(address(this), liquidity);
    \_safeTransfer(\_token0, to, amount0);
    \_safeTransfer(\_token1, to, amount1);
    balance0 = IERC20Uniswap(\_token0).balanceOf(address(this));
    balance1 = IERC20Uniswap(\_token1).balanceOf(address(this));

    \_update(balance0, balance1, \_reserve0, \_reserve1);
    if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date
    emit Burn(msg.sender, amount0, amount1, to);
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>pairForOldRouter Used to calculate the of a pair without any external calls CREATE2 Address</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre>// calculates the CREATE2 address for a pair without making any external calls
function pairForOldRouter(address tokenA, address tokenB) internal view returns (address pair) {
    (address token0, address token1) = UniswapV2Library.sortTokens(tokenA, tokenB);
    pair = address(uint(keccak256(abi.encodePacked(
            hex'ff',
            oldRouter.factory(),
            keccak256(abi.encodePacked(token0, token1)),
            hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash
        ))));
</pre></td></tr></tbody></table></code></pre></div></div>

<p>addLiquidity Used to increase liquidity Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="rouge-code"><pre>function addLiquidity(
    address tokenA,
    address tokenB,
    uint256 amountADesired,
    uint256 amountBDesired
) internal returns (uint amountA, uint amountB) {
    (amountA, amountB) = \_addLiquidity(tokenA, tokenB, amountADesired, amountBDesired);
    address pair = UniswapV2Library.pairFor(router.factory(), tokenA, tokenB);
    IERC20(tokenA).safeTransfer(pair, amountA);
    IERC20(tokenB).safeTransfer(pair, amountB);
    IUniswapV2Pair(pair).mint(msg.sender);
}

function \_addLiquidity(
    address tokenA,
    address tokenB,
    uint256 amountADesired,
    uint256 amountBDesired
) internal returns (uint256 amountA, uint256 amountB) {
    // create the pair if it doesn't exist yet
    IUniswapV2Factory factory = IUniswapV2Factory(router.factory());
    if (factory.getPair(tokenA, tokenB) == address(0)) {
        factory.createPair(tokenA, tokenB);
    }
    (uint256 reserveA, uint256 reserveB) = UniswapV2Library.getReserves(address(factory), tokenA, tokenB);
    if (reserveA == 0 &amp;&amp; reserveB == 0) {
        (amountA, amountB) = (amountADesired, amountBDesired);
    } else {
        uint256 amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);
        if (amountBOptimal &lt;= amountBDesired) {
            (amountA, amountB) = (amountADesired, amountBOptimal);
        } else {
            uint256 amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);
            assert(amountAOptimal &lt;= amountADesired);
            (amountA, amountB) = (amountAOptimal, amountBDesired);
        }
    }
} }
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="safety-problem"><strong>safety problem</strong></h4>

<p>Here we‚Äôre going to look at the above SushiSwap Two security issues in the contract are briefly analyzed Ôºö</p>

<h5 id="conditional-competition"><strong>Conditional competition</strong></h5>

<p>Vulnerability function ÔºöemergencyWithdraw</p>

<p>Vulnerability code Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre>// Withdraw without caring about rewards. EMERGENCY ONLY.
function emergencyWithdraw(uint256 \_pid) public {
    PoolInfo storage pool = poolInfo\[\_pid\];
    UserInfo storage user = userInfo\[\_pid\]\[msg.sender\];
    pool.lpToken.safeTransfer(address(msg.sender), user.amount);
    emit EmergencyWithdraw(msg.sender, \_pid, user.amount);
    user.amount = 0;
    user.rewardDebt = 0;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Vulnerability description Ôºö As described in the code above , there emergencyWithdraw Function for emergency withdrawal , But the renewal of assets is after the transfer , Lead to conditional competition .</p>

<p>Solution Ôºö The correct wording should be as follows</p>

<p>function emergencyWithdraw(uint256 _pid) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        uint256 amount = user.amount;
        user.amount = 0;
        user.rewardDebt = 0;
        pool.lpToken.safeTransfer(address(msg.sender), amount);
        emit EmergencyWithdraw(msg.sender, _pid, amount);
    }</p>

<h5 id="reenter-attack"><strong>Reenter attack</strong></h5>

<p>Vulnerability function ÔºösetMigrator+migrate</p>

<p>Vulnerability code Ôºö</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre>// Set the migrator contract. Can only be called by the owner.
function setMigrator(IMigratorChef \_migrator) public onlyOwner {
    migrator = \_migrator;
}

// Migrate lp token to another lp contract. Can be called by anyone. We trust that migrator contract is good.
function migrate(uint256 \_pid) public {
    require(address(migrator) != address(0), "migrate: no migrator");
    PoolInfo storage pool = poolInfo\[\_pid\];
    IERC20 lpToken = pool.lpToken;
    uint256 bal = lpToken.balanceOf(address(this));
    lpToken.safeApprove(address(migrator), bal);
    IERC20 newLpToken = migrator.migrate(lpToken);
    require(bal == newLpToken.balanceOf(address(this)), "migrate: bad");
    pool.lpToken = newLpToken;
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Vulnerability description Ôºö In the above code, you can see the contract owner You can set migrator, When migrator After the value of is determined migrator.migrate(lpToken) Can be determined accordingly , because migrate The way is through IMigratorChef Interface to be called , So when called ,migrate The logical code in the method will be based on migrator Values vary , At this point, if the smart contract owner take migrator The value of points to a containing malicious migrate Smart contract for method code , Then the owner can do any malicious operation he wants , It‚Äôs even possible to empty all the tokens in the account , At the same time migrator.migrate(lpToken) After this line of code is executed , Contract owners can also exploit reentry attacks , Re execute from migrate Methods or other smart contract methods , Perform malicious operations .</p>

<p>Solution Ôºö Setting up reasonable owner Authority</p>

<h4 id="summary-at-the-end-of-the-paper"><strong>Summary at the end of the paper</strong></h4>

<p>SushiSwap Is in UniswapV2 Based on the agreement , Because its emergency reward model is more biased towards the interests of users , So compared with UniswapV2 It is easier to attract more users to participate in pledge to provide liquidity , At the same time, this article also reveals the problem of permission „ÄÅ Security risks exposed by coding logic design .</p>

<h4 id="reference-link"><strong>Reference link</strong></h4>

<p>https://app.sushi.com/</p>

<p>https://docs.sushi.com/</p>

<p>https://help.sushidocs.com/</p>

<p>https://sushiswapchef.medium.com</p>


        <!-- Post Pager -->
        <div>
          <hr style="visibility: hidden" />
          <ul class="pager"><li class="previous">
              <a
                href="/primitives/2021/12/20/Web3-Technical-Debt-Creep.html"
                data-toggle="tooltip"
                data-placement="top"
                title=" The Mythical Web3 Developer Experience"
              >
                Previous<br />
                <span> The Mythical Web3 Developer Experience</span>
              </a>
            </li><li class="next">
              <a
                href="/primitives/2022/01/10/Liquidity-adjusted-arrival-price.html"
                data-toggle="tooltip"
                data-placement="top"
                title="Liquidity Adjusted Arrival Price"
              >
                Next<br />
                <span>Liquidity Adjusted Arrival Price</span>
              </a>
            </li></ul>
          <hr style="visibility: hidden" />
        </div><!-- Comments -->
<script
  src="https://utteranc.es/client.js"
  repo="sambacha/comments"
  issue-term="pathname"
  theme="github-light"
  crossorigin="anonymous"
  async
></script></div><!-- Side Catalog Container -->
      <div
        class="col-lg-2 col-lg-offset-0 visible-lg-block sidebar-container catalog-container"
      >
        <div class="side-catalog">
          <hr class="hidden-sm hidden-xs" />
          <h5>
            <a class="catalog-toggle" href="#">CATALOG</a>
          </h5>
          <ul class="catalog-body"></ul>
        </div>
      </div><!-- Sidebar Container -->
      <div
        class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 sidebar-container"
      ><!-- Featured Tags -->
<section><hr class="hidden-sm hidden-xs"><h5>
        <a href="/primitives/archive/">FEATURED TAGS</a>
    </h5>
    <div class="tags"><a data-sort="0002"
            href="/primitives/archive/?tag=blockchain"
            title="blockchain"
            rel="2">blockchain</a><a data-sort="0002"
            href="/primitives/archive/?tag=distributed+computing"
            title="distributed computing"
            rel="2">distributed computing</a><a data-sort="0002"
            href="/primitives/archive/?tag=ethereum"
            title="ethereum"
            rel="2">ethereum</a><a data-sort="0003"
            href="/primitives/archive/?tag=amm"
            title="amm"
            rel="1">amm</a><a data-sort="0003"
            href="/primitives/archive/?tag=analysis"
            title="analysis"
            rel="1">analysis</a><a data-sort="0003"
            href="/primitives/archive/?tag=dao"
            title="dao"
            rel="1">dao</a><a data-sort="0003"
            href="/primitives/archive/?tag=governance"
            title="governance"
            rel="1">governance</a><a data-sort="0003"
            href="/primitives/archive/?tag=protocol"
            title="protocol"
            rel="1">protocol</a><a data-sort="0003"
            href="/primitives/archive/?tag=routing"
            title="routing"
            rel="1">routing</a><a data-sort="0003"
            href="/primitives/archive/?tag=sushiswap"
            title="sushiswap"
            rel="1">sushiswap</a><a data-sort="0003"
            href="/primitives/archive/?tag=trading"
            title="trading"
            rel="1">trading</a>
    </div>
</section>
</div>
    </div>
  </div>
</article>
<!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><!-- SNS -->
<ul class="list-inline text-center">
  
  <li>
    <a href="/primitives/feed.xml">
      <span class="fa-stack fa-lg">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li><li>
    <a target="_blank" href="mailto:sam@manifoldfinance.com">
      <span class="fa-stack fa-lg">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li><li>
    <a target="_blank" href="https://github.com/sambacha">
      <span class="fa-stack fa-lg">
        <i class="fas fa-circle fa-stack-2x fa-inverse"></i>
        <i class="fab fa-github fa-stack-2x"></i>
      </span>
    </a>
  </li></ul>
<p class="copyright text-muted">See
          <a href="https://github.com/sambacha"></a> @sambacha | &copy; 2021-2022 sambacha
        </p>
      </div>
    </div>
  </div>
</footer>

<!-- jQuery -->
<script
  src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js"
  integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg=="
  crossorigin="anonymous"
></script>

<!-- Bootstrap JavaScript-->
<!-- Currently, only navbar scroll-down effect at desktop still depends on this -->
<script
  src="https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"
  integrity="sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd"
  crossorigin="anonymous"
></script>

<!-- Simple Jekyll Search -->
<script
  src="https://cdnjs.cloudflare.com/ajax/libs/simple-jekyll-search/1.7.12/simple-jekyll-search.min.js"
  integrity="sha512-APy7Ff/y4pdIHleqiTMcRZ8Wu6tjfqhJpgAcaCvTuFQPj/G+/A5u0uZi/DkfkuLQ6FeFmDJgh/zl0y3If/VUyA=="
  crossorigin="anonymous"
></script>

<!-- MathJax https://github.com/mathjax/MathJax/issues/2220 -->
<script>
  MathJax = {
    options: {
      renderActions: {
        /* add a new named action not to override the original 'find' action */
        find_script_mathtex: [
          10,
          function (doc) {
            for (const node of document.querySelectorAll(
              'script[type^="math/tex"]',
            )) {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(
                node.textContent,
                doc.inputJax[0],
                display,
              );
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = { node: text, delim: '', n: 0 };
              math.end = { node: text, delim: '', n: 0 };
              doc.math.push(math);
            }
          },
          '',
        ],
      },
    },
  };
</script>
<script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.0.5/es5/tex-chtml.js"
  integrity="sha512-WIPUeuVusAT6dUtN6xKArYCBEa76ltyvaz3ltvQd+dy7ISdGJv1Y3y7eDBEF986YfNtmZGLdAaEBSgeBb+8OSg=="
  crossorigin="anonymous"
></script>

<!-- Async load function -->
<script>
  function async(u, c) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) {
      o.addEventListener(
        'load',
        function (e) {
          c(null, e);
        },
        false,
      );
    }
    s.parentNode.insertBefore(o, s);
  }
</script><!-- AnchorJS -->
<script>
  async(
    'https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.2.2/anchor.min.js',
    function () {
      anchors.options = {
        visible: 'hover',
      };
      anchors
        .add()
        .remove('.intro-header h1')
        .remove('.subheading')
        .remove('.sidebar-container h5');
    },
  );
</script><!-- Custom JavaScript -->
<script src="/primitives/assets/js/main.js"></script><!-- Side Catalog -->
<script src="/primitives/assets/js/catalog.js"></script></body>
</html>
